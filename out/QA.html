<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Вопросы для подготовки – Вопросы для подготовки</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Вопросы для подготовки</h1>
</header>
<h1 id="вопросы-для-подготовки">Вопросы для подготовки</h1>
<h2 id="java-core">Java Core</h2>
<h3 id="типы-данных-в-java">1. Типы данных в Java</h3>
<ul>
<li>Примитивные: <code>byte</code>, <code>short</code>,
<code>int</code>, <code>long</code>, <code>float</code>,
<code>double</code>, <code>char</code>, <code>boolean</code>.<br />
</li>
<li>Объектные (ссылочные): Все классы (включая <code>String</code>,
массивы, пользовательские классы).</li>
</ul>
<h3 id="объектные-vs-примитивные-типы">2. Объектные vs примитивные
типы</h3>
<ul>
<li>Примитивные хранят значение, объектные — ссылки.<br />
</li>
<li>Примитивные не могут быть <code>null</code>, имеют значения по
умолчанию (например, <code>0</code>).<br />
</li>
<li>Объектные требуют больше памяти, поддерживают методы.</li>
</ul>
<h3 id="передача-параметров">3. Передача параметров</h3>
<ul>
<li>В Java всегда передача по значению:
<ul>
<li>Для примитивов — копия значения.<br />
</li>
<li>Для объектов — копия ссылки (изменения внутри метода влияют на
объект).</li>
</ul></li>
</ul>
<h3 id="outofmemoryerror">4. OutOfMemoryError</h3>
<ul>
<li>Ошибка при нехватке памяти в heap.<br />
</li>
<li>Причины: утечки памяти, большие структуры данных.<br />
</li>
<li>Диагностика: профилировщики (VisualVM, MAT).</li>
</ul>
<h3 id="стектрейс">5. Стектрейс</h3>
<ul>
<li>Цепочка вызовов методов до точки ошибки.<br />
</li>
<li>Получить: <code>e.printStackTrace()</code> или
<code>Thread.currentThread().getStackTrace()</code>.</li>
</ul>
<h3 id="методы-класса-object">6. Методы класса Object</h3>
<ul>
<li><code>toString()</code>, <code>equals()</code>,
<code>hashCode()</code>, <code>clone()</code>, <code>getClass()</code>,
<code>finalize()</code>, <code>notify()</code>,
<code>notifyAll()</code>, <code>wait()</code> (3 перегрузки).</li>
</ul>
<h3 id="конструкторы">7. Конструкторы</h3>
<ul>
<li>Специальные методы для инициализации объекта.<br />
</li>
<li>Типы: по умолчанию (без параметров), параметризованные, приватные
(для singleton), копирования.</li>
</ul>
<h3 id="immutable-стандартные-классы">8. Immutable стандартные
классы</h3>
<ul>
<li><code>String</code>, <code>Integer</code>, <code>Double</code>,
<code>LocalDate</code>, <code>BigDecimal</code>, <code>Duration</code>,
<code>UUID</code>.</li>
</ul>
<h3 id="immutable-объекты">9. Immutable объекты</h3>
<ul>
<li>Характеристика: Состояние не меняется после создания.<br />
</li>
<li>Зачем: Безопасность в многопоточности, предсказуемость.<br />
</li>
<li>Создать: <code>final</code> класс + поля, отсутствие сеттеров,
возврат копий в геттерах.<br />
</li>
<li>Преимущества: Потокобезопасность, простота кэширования, отсутствие
side-эффектов.</li>
</ul>
<h2 id="ооп">ООП</h2>
<h3 id="ооп-1">1. ООП</h3>
<p>Парадигма программирования, основанная на объектах. Принципы:</p>
<ul>
<li>Инкапсуляция (скрытие данных: <code>private</code> поля +
геттеры/сеттеры).<br />
</li>
<li>Наследование (<code>class Dog extends Animal</code>).<br />
</li>
<li>Полиморфизм (перегрузка/переопределение методов).<br />
</li>
<li>Абстракция (интерфейсы, абстрактные классы).</li>
</ul>
<h3 id="наследование">2. Наследование</h3>
<p>Позволяет классу (потомку) использовать поля/методы другого класса
(родителя). Пример: <code>class ElectricCar extends Car</code>.<br />
Зачем: Повторное использование кода, иерархия.</p>
<h3 id="полиморфизм">3. Полиморфизм</h3>
<p>Обращение к объектам разных классов через общий интерфейс. Работает
через:</p>
<ul>
<li>Переопределение методов (<code>@Override</code>).<br />
</li>
<li>Перегрузку методов (разные сигнатуры).<br />
Пример:
<code>List&lt;String&gt; list = new ArrayList&lt;&gt;()</code>.</li>
</ul>
<h3 id="абстракция">4. Абстракция</h3>
<p>Сокрытие сложности через интерфейсы/абстрактные классы. Пример:
<code>interface Shape</code> с методом <code>draw()</code>.</p>
<h3 id="инкапсуляция">5. Инкапсуляция</h3>
<ul>
<li>Модификаторы доступа (<code>private</code>,
<code>protected</code>).<br />
</li>
<li>Геттеры/сеттеры.<br />
</li>
<li>Класс как капсула данных и методов.</li>
</ul>
<h3 id="наследование-в-java">6. Наследование в Java</h3>
<ul>
<li>Ключевое слово <code>extends</code>.<br />
</li>
<li><code>super</code>: вызов конструктора/метода родителя
(<code>super()</code> или <code>super.method()</code>).</li>
</ul>
<h3 id="полиморфизм-в-java">7. Полиморфизм в Java</h3>
<ul>
<li>Переопределение методов (<code>@Override</code>).<br />
</li>
<li>Интерфейсы (<code>implements</code>).<br />
</li>
<li>Перегрузка методов (разные параметры).</li>
</ul>
<h3 id="перегрузка-overloading">8. Перегрузка (overloading)</h3>
<p>Методы с одинаковым именем, но разными параметрами. Пример:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">print</span><span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span>  </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">print</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span>  </span></code></pre></div>
<h3 id="переопределение-override">9. Переопределение (override)</h3>
<p>Изменение реализации метода в подклассе. Пример:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="at">@Override</span>  </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="bu">String</span> <span class="fu">toString</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span>  </span></code></pre></div>
<h3 id="класс-объект-интерфейс">10. Класс, объект, интерфейс</h3>
<ul>
<li>Класс: Шаблон для создания объектов.<br />
</li>
<li>Объект: Экземпляр класса.<br />
</li>
<li>Интерфейс: Контракт методов (<code>interface Runnable</code>).</li>
</ul>
<h3 id="элементы-класса">11. Элементы класса</h3>
<p>Поля, методы, конструкторы, вложенные классы, блоки
инициализации.</p>
<h3 id="сигнатура-метода">12. Сигнатура метода</h3>
<p>Имя метода + типы/порядок параметров. Пример:
<code>add(int a, int b)</code>.</p>
<h3 id="return-в-конструкторе">13. return в конструкторе</h3>
<p>Да, можно использовать <code>return;</code> для завершения, но нельзя
возвращать значение.</p>
<h3 id="исключения-в-конструкторе">14. Исключения в конструкторе</h3>
<p>Да, можно. Пример:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="fu">MyClass</span><span class="op">()</span> <span class="kw">throws</span> <span class="bu">IOException</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span>  </span></code></pre></div>
<h3 id="ключевое-слово-this">15. Ключевое слово this</h3>
<ul>
<li>Разрешение конфликта имен (поля vs параметры).<br />
</li>
<li>Вызов других конструкторов (<code>this()</code>).</li>
</ul>
<h3 id="модификаторы-доступа">16. Модификаторы доступа</h3>
<ul>
<li><code>public</code>: Доступ везде.<br />
</li>
<li><code>protected</code>: Тот же пакет + подклассы.<br />
</li>
<li><code>private</code>: Только внутри класса.<br />
</li>
<li>По умолчанию: Тот же пакет.</li>
</ul>
<h3 id="статические-переменныеметоды">17. Статические
переменные/методы</h3>
<ul>
<li>Принадлежат классу, а не объекту.<br />
</li>
<li>Ограничения: Не могут использовать <code>this</code>, обращаться к
нестатическим полям/методам напрямую.</li>
</ul>
<h3 id="ключевое-слово-static">18. Ключевое слово static</h3>
<ul>
<li>Статический метод можно перегрузить, но нельзя переопределить.</li>
</ul>
<h3 id="использование-static-методов">19. Использование static
методов</h3>
<ul>
<li>Статические методы можно вызывать из обычных (через имя
класса).<br />
</li>
<li>Обычные методы нельзя вызвать из статических без объекта.</li>
</ul>
<h3 id="final">20. final</h3>
<ul>
<li>Поля: Неизменяемые после инициализации.<br />
</li>
<li>Классы: Запрет наследования.<br />
</li>
<li>Методы: Запрет переопределения.</li>
</ul>
<h3 id="abstract">21. abstract</h3>
<ul>
<li>Абстрактный класс: Нельзя создать объект.<br />
</li>
<li>Абстрактный метод: Без реализации (должен быть переопределен).</li>
</ul>
<h3 id="interface">22. interface</h3>
<p>Контракт методов. Не может быть <code>final</code> (должен быть
реализован).</p>
<h3 id="абстрактный-класс-vs-интерфейс">23. Абстрактный класс vs
интерфейс</h3>
<ul>
<li>Абстрактный класс: Поля, конструкторы, реализация методов.<br />
</li>
<li>Интерфейс: Только абстрактные методы (до Java 8), константы.</li>
</ul>
<h3 id="модификаторы-доступа-класса">24. Модификаторы доступа
класса</h3>
<ul>
<li><code>public</code>: Доступ везде.<br />
</li>
<li>Без модификатора (package-private): Только в том же пакете.</li>
</ul>
<h2 id="string">String</h2>
<h3 id="класс-string-в-java">1. Класс String в Java</h3>
<ul>
<li>Неизменяемый (immutable) класс для работы с последовательностями
символов.<br />
</li>
<li>Реализует интерфейсы <code>CharSequence</code>,
<code>Serializable</code>, <code>Comparable&lt;String&gt;</code>.<br />
</li>
<li>Хранится в куче (heap), но с оптимизацией через строковый пул
(String Pool).</li>
</ul>
<h3 id="способы-создания-string">2. Способы создания String</h3>
<ul>
<li>Литерал: <code>String s = "text";</code> (попадает в String
Pool).<br />
</li>
<li>Через конструктор: <code>new String("text")</code> (создает новый
объект в куче).<br />
</li>
<li>Из массива символов:
<code>new char[] {'t','e','x','t'}</code>.<br />
</li>
<li>Через <code>StringBuilder</code>/<code>StringBuffer</code>:
<code>new StringBuilder().toString()</code>.</li>
</ul>
<h3 id="сравнение-и-сортировка-строк">3. Сравнение и сортировка
строк</h3>
<ul>
<li><code>==</code>: Сравнивает ссылки, а не содержимое.<br />
</li>
<li><code>equals()</code>: Сравнивает содержимое строк.<br />
</li>
<li><code>compareTo()</code>: Для сортировки (возвращает разницу в
Unicode).<br />
</li>
<li><code>Arrays.sort()</code> или <code>Collections.sort()</code> с
компаратором.</li>
</ul>
<h3 id="строковый-пул-string-pool">4. Строковый пул (String Pool)</h3>
<ul>
<li>Специальная область в heap для хранения уникальных строковых
литералов.<br />
</li>
<li>Цель: Экономия памяти за счет переиспользования строк.<br />
</li>
<li>При создании через литерал (<code>"text"</code>) JVM сначала
проверяет String Pool.</li>
</ul>
<h3 id="string-vs-stringbuffer-vs-stringbuilder">5. String vs
StringBuffer vs StringBuilder</h3>
<ul>
<li>String: Неизменяемый. Подходит для констант, ключей в
<code>HashMap</code>.<br />
</li>
<li>StringBuffer: Изменяемый, потокобезопасный (синхронизированные
методы).<br />
</li>
<li>StringBuilder: Изменяемый, не потокобезопасный, быстрее
StringBuffer.<br />
</li>
<li>Использовать:
<ul>
<li><code>String</code> для редко меняющихся данных.<br />
</li>
<li><code>StringBuilder</code> для однопоточных операций.<br />
</li>
<li><code>StringBuffer</code> для многопоточных.</li>
</ul></li>
</ul>
<h3 id="примеры">Примеры</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Создание строк</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> s1 <span class="op">=</span> <span class="st">&quot;Hello&quot;</span><span class="op">;</span>        <span class="co">// String Pool</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> s2 <span class="op">=</span> <span class="kw">new</span> <span class="bu">String</span><span class="op">(</span><span class="st">&quot;Hello&quot;</span><span class="op">);</span> <span class="co">// Heap</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Сравнение</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="dt">boolean</span> isEqual <span class="op">=</span> s1<span class="op">.</span><span class="fu">equals</span><span class="op">(</span>s2<span class="op">);</span> <span class="co">// true</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">// StringBuilder</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="bu">StringBuilder</span> sb <span class="op">=</span> <span class="kw">new</span> <span class="bu">StringBuilder</span><span class="op">();</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>sb<span class="op">.</span><span class="fu">append</span><span class="op">(</span><span class="st">&quot;Hello&quot;</span><span class="op">).</span><span class="fu">append</span><span class="op">(</span><span class="st">&quot; World&quot;</span><span class="op">);</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> result <span class="op">=</span> sb<span class="op">.</span><span class="fu">toString</span><span class="op">();</span> <span class="co">// &quot;Hello World&quot;</span></span></code></pre></div>
<h2 id="enum">Enum</h2>
<h3 id="краткая-характеристика-enum">1. Краткая характеристика Enum</h3>
<ul>
<li>Тип данных для фиксированного набора констант (безопасная замена
<code>int</code>/<code>String</code> констант).<br />
</li>
<li>Может содержать поля, методы, конструкторы.<br />
</li>
<li>Неявно наследуется от <code>java.lang.Enum</code>.</li>
</ul>
<h3 id="реализация-интерфейса">2. Реализация интерфейса</h3>
<p>Да. Пример:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> Loggable <span class="op">{</span> <span class="dt">void</span> <span class="fu">log</span><span class="op">();</span> <span class="op">}</span>  </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Status <span class="kw">implements</span> Loggable <span class="op">{</span>  </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">ACTIVE</span> <span class="op">{</span> <span class="kw">public</span> <span class="dt">void</span> <span class="fu">log</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span> <span class="op">},</span>  </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">INACTIVE</span> <span class="op">{</span> <span class="kw">public</span> <span class="dt">void</span> <span class="fu">log</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span> <span class="op">}</span>  </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  </span></code></pre></div>
<h3 id="наследование-extends">3. Наследование (extends)</h3>
<p>Нет. Enum не может наследовать классы (кроме неявного наследования от
<code>java.lang.Enum</code>).</p>
<h3 id="enum-без-экземпляров">4. Enum без экземпляров</h3>
<p>Нет. Должен содержать минимум одну константу.</p>
<h3 id="переопределение-tostring">5. Переопределение
<code>toString()</code></h3>
<p>Да. Пример:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="bu">Color</span> <span class="op">{</span> RED <span class="op">{</span> <span class="kw">public</span> <span class="bu">String</span> <span class="fu">toString</span><span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;Красный&quot;</span><span class="op">;</span> <span class="op">}</span> <span class="op">}</span>  </span></code></pre></div>
<h3 id="поведение-tostring-по-умолчанию">6. Поведение
<code>toString()</code> по умолчанию</h3>
<p>Возвращает имя константы (например, <code>RED</code> для
<code>Color.RED</code>).</p>
<h3 id="конструктор-в-enum">7. Конструктор в Enum</h3>
<p>Да. Конструктор должен быть <code>private</code>:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Size <span class="op">{</span> <span class="fu">SMALL</span><span class="op">(</span><span class="dv">10</span><span class="op">),</span> <span class="fu">MEDIUM</span><span class="op">(</span><span class="dv">20</span><span class="op">);</span>  </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span> <span class="dt">int</span> value<span class="op">;</span>  </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span> <span class="fu">Size</span><span class="op">(</span><span class="dt">int</span> value<span class="op">)</span> <span class="op">{</span> <span class="kw">this</span><span class="op">.</span><span class="fu">value</span> <span class="op">=</span> value<span class="op">;</span> <span class="op">}</span>  </span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  </span></code></pre></div>
<h3 id="vs-equals">8. <code>==</code> vs <code>equals()</code></h3>
<ul>
<li><code>==</code> сравнивает ссылки (безопасно, т.к. константы
уникальны).<br />
</li>
<li><code>equals()</code> вызывает <code>==</code> под капотом.</li>
</ul>
<h3 id="метод-ordinal">9. Метод <code>ordinal()</code></h3>
<ul>
<li>Возвращает порядковый номер константы (начинается с 0).<br />
</li>
<li>Пример: <code>Color.RED.ordinal()</code> → 0.</li>
</ul>
<h3 id="enum-в-treesettreemap">10. Enum в
<code>TreeSet</code>/<code>TreeMap</code></h3>
<ul>
<li>Да. Сортировка по <code>natural order</code> (порядок объявления
констант).</li>
</ul>
<h3 id="связь-ordinal-и-compareto">11. Связь <code>ordinal()</code> и
<code>compareTo()</code></h3>
<ul>
<li><code>compareTo()</code> использует <code>ordinal()</code> для
сравнения.</li>
</ul>
<h3 id="enum-в-switch-case">12. Enum в <code>switch case</code></h3>
<ul>
<li><p>Да. Пример:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>color<span class="op">)</span> <span class="op">{</span>  </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> RED<span class="op">:</span> <span class="kw">...</span> <span class="cf">break</span><span class="op">;</span>  </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> BLUE<span class="op">:</span> <span class="kw">...</span> <span class="cf">break</span><span class="op">;</span>  </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  </span></code></pre></div></li>
</ul>
<h3 id="получение-всех-значений-enum">13. Получение всех значений
Enum</h3>
<ul>
<li><p>Метод <code>values()</code>:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">Color</span><span class="op">[]</span> colors <span class="op">=</span> <span class="bu">Color</span><span class="op">.</span><span class="fu">values</span><span class="op">();</span> <span class="co">// [RED, GREEN, BLUE]  </span></span></code></pre></div></li>
</ul>
<h2 id="фунциональные-интерфейсы">Фунциональные интерфейсы</h2>
<h3 id="функциональный-интерфейс">1. Функциональный интерфейс</h3>
<ul>
<li>Интерфейс с одним абстрактным методом (SAM).<br />
</li>
<li>Может иметь <code>default</code>/<code>static</code> методы.<br />
</li>
<li>Аннотация <code>@FunctionalInterface</code> (проверяет условие на
этапе компиляции).<br />
</li>
<li>Пример: <code>Runnable</code>, <code>Comparator</code>.</li>
</ul>
<h3 id="стандартные-функциональные-интерфейсы">2. Стандартные
функциональные интерфейсы</h3>
<ul>
<li><code>Predicate&lt;T&gt;</code>: Проверяет условие
(<code>test(T t)</code> → <code>boolean</code>).<br />
</li>
<li><code>Function&lt;T,R&gt;</code>: Преобразует <code>T</code> в
<code>R</code> (<code>apply(T t)</code> → <code>R</code>).<br />
</li>
<li><code>Consumer&lt;T&gt;</code>: Принимает <code>T</code>, ничего не
возвращает (<code>accept(T t)</code>).<br />
</li>
<li><code>Supplier&lt;T&gt;</code>: Поставляет значение
(<code>get()</code> → <code>T</code>).<br />
</li>
<li><code>UnaryOperator&lt;T&gt;</code>:
<code>Function&lt;T,T&gt;</code> (например,
<code>x -&gt; x + 1</code>).<br />
</li>
<li><code>BinaryOperator&lt;T&gt;</code>: Принимает два <code>T</code>,
возвращает <code>T</code> (например,
<code>(a, b) -&gt; a + b</code>).</li>
</ul>
<h3 id="лямбда-выражение">3. Лямбда-выражение</h3>
<ul>
<li><p>Анонимная функция, реализующая метод функционального
интерфейса.<br />
</p></li>
<li><p>Синтаксис: <code>(параметры) -&gt; { тело }</code>.<br />
</p></li>
<li><p>Пример:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>Function<span class="op">&lt;</span><span class="bu">Integer</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> square <span class="op">=</span> x <span class="op">-&gt;</span> x <span class="op">*</span> x<span class="op">;</span></span></code></pre></div></li>
</ul>
<h3 id="ссылка-на-метод">4. Ссылка на метод (<code>::</code>)</h3>
<ul>
<li><p>Сокращенная запись для вызова существующего метода.<br />
</p></li>
<li><p>Типы:</p>
<ul>
<li>Статический метод: <code>ClassName::method</code>.<br />
</li>
<li>Метод экземпляра: <code>instance::method</code> или
<code>ClassName::method</code> (нестатический).<br />
</li>
<li>Конструктор: <code>ClassName::new</code>.<br />
</li>
</ul></li>
<li><p>Отличие от лямбды: Не создает новую реализацию, а ссылается на
существующий метод.<br />
</p></li>
<li><p>Пример:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>Consumer<span class="op">&lt;</span><span class="bu">String</span><span class="op">&gt;</span> printer <span class="op">=</span> <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>println<span class="op">;</span></span></code></pre></div></li>
</ul>
<h2 id="stream-api">Stream API</h2>
<h3 id="stream-api-в-java">1. Stream API в Java</h3>
<p>Интерфейс для обработки коллекций/данных в функциональном стиле.
Позволяет выполнять операции (фильтрация, преобразование, агрегация)
цепочкой. Не изменяет исходные данные.</p>
<h3 id="создание-stream-из-коллекции">2. Создание Stream из
коллекции</h3>
<ul>
<li><code>collection.stream()</code>: Создает последовательный
стрим.<br />
</li>
<li><code>collection.parallelStream()</code>: Создает параллельный
стрим.<br />
</li>
<li><code>Stream.of(...)</code>, <code>Arrays.stream(array)</code>: Для
массивов/наборов элементов.</li>
</ul>
<h3 id="промежуточные-операции">3. Промежуточные операции</h3>
<p>Операции, возвращающие новый Stream (ленивые, выполняются при вызове
терминальной операции). Примеры:</p>
<ul>
<li><code>filter(Predicate)</code>: Фильтрация элементов.<br />
</li>
<li><code>map(Function)</code>: Преобразование элементов.<br />
</li>
<li><code>sorted()</code>, <code>distinct()</code>,
<code>limit(n)</code>.</li>
</ul>
<h3 id="терминальные-операции">4. Терминальные операции</h3>
<p>Завершают обработку Stream, возвращают результат (число, коллекцию и
т.д.). Примеры:</p>
<ul>
<li><code>collect(Collectors.toList())</code>: Сохранение в
коллекцию.<br />
</li>
<li><code>forEach(Consumer)</code>: Выполнение действия для каждого
элемента.<br />
</li>
<li><code>reduce()</code>, <code>count()</code>, <code>min()</code>,
<code>max()</code>.</li>
</ul>
<h3 id="параллельные-стримы">5. Параллельные стримы</h3>
<p>Обработка элементов в нескольких потоках. Создается через
<code>parallelStream()</code>. Требует осторожности с
потокобезопасностью.</p>
<h3 id="группировка-элементов">6. Группировка элементов</h3>
<ul>
<li><code>Collectors.groupingBy(Function)</code>: Группировка по
ключу.<br />
</li>
<li><code>Collectors.partitioningBy(Predicate)</code>: Разделение на
<code>true</code>/<code>false</code>.</li>
</ul>
<h3 id="метод-filter">7. Метод <code>filter</code></h3>
<p>Принимает <code>Predicate&lt;T&gt;</code> (функцию, возвращающую
<code>boolean</code>). Пример:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>list<span class="op">.</span><span class="fu">stream</span><span class="op">().</span><span class="fu">filter</span><span class="op">(</span>s <span class="op">-&gt;</span> s<span class="op">.</span><span class="fu">length</span><span class="op">()</span> <span class="op">&gt;</span> <span class="dv">3</span><span class="op">)</span>  </span></code></pre></div>
<h3 id="дополнение">Дополнение</h3>
<ul>
<li>Ленивые вычисления: Промежуточные операции выполняются только при
вызове терминальной.<br />
</li>
<li>Порядок операций: Влияет на производительность (например,
<code>filter</code> перед <code>map</code>).</li>
</ul>
<h2 id="collections">Collections</h2>
<h3 id="иерархия-коллекций">1. Иерархия коллекций</h3>
<ul>
<li>Интерфейсы: <code>Collection</code> → <code>List</code>,
<code>Set</code>, <code>Queue</code>; <code>Map</code> (отдельная
иерархия).<br />
</li>
<li>Реализации: <code>List</code> → <code>ArrayList</code>,
<code>LinkedList</code>; <code>Set</code> → <code>HashSet</code>,
<code>TreeSet</code>; <code>Map</code> → <code>HashMap</code>,
<code>TreeMap</code>.</li>
</ul>
<h3 id="внутреннее-строение-arraylist">2. Внутреннее строение
ArrayList</h3>
<ul>
<li>Динамический массив (<code>Object[]</code>).<br />
</li>
<li>Начальная ёмкость: 10. При заполнении увеличивается на 50%
(<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>).</li>
</ul>
<h3 id="внутреннее-строение-linkedlist">3. Внутреннее строение
LinkedList</h3>
<ul>
<li>Двусвязный список: каждый элемент (<code>Node</code>) содержит
ссылки на предыдущий и следующий узлы.<br />
</li>
<li>Нет необходимости в увеличении ёмкости, но больше памяти на
ссылки.</li>
</ul>
<h3 id="внутреннее-строение-hashmap">4. Внутреннее строение HashMap</h3>
<ul>
<li>Массив бакетов (по умолчанию: 16).<br />
</li>
<li>Каждый бакет — связный список или сбалансированное дерево (при
коллизиях, Java 8+).<br />
</li>
<li>Хэш-функция: <code>hashCode()</code> ключа → индекс бакета.</li>
</ul>
<h3 id="arraylist-vs-linkedlist">5. ArrayList vs LinkedList</h3>
<ul>
<li>ArrayList: Быстрый доступ по индексу (<code>O(1)</code>), медленные
вставка/удаление в середине (<code>O(n)</code>).<br />
</li>
<li>LinkedList: Медленный доступ по индексу (<code>O(n)</code>), быстрые
вставка/удаление (<code>O(1)</code>).</li>
</ul>
<h3 id="arraylist-vs-hashset">6. ArrayList vs HashSet</h3>
<ul>
<li>ArrayList: Дубликаты разрешены, порядок элементов сохраняется.<br />
</li>
<li>HashSet: Дубликаты запрещены, порядок не гарантирован.</li>
</ul>
<h3 id="многообразие-динамических-массивов">7. Многообразие динамических
массивов</h3>
<ul>
<li>Разные требования:
<ul>
<li><code>ArrayList</code> — для быстрого доступа.<br />
</li>
<li><code>Vector</code> — потокобезопасная версия.<br />
</li>
<li><code>CopyOnWriteArrayList</code> — для многопоточности.</li>
</ul></li>
</ul>
<h3 id="многообразие-key-value-storage">8. Многообразие key-value
storage</h3>
<ul>
<li>HashMap: Быстрый доступ, порядок не гарантирован.<br />
</li>
<li>TreeMap: Сортировка по ключам (<code>Comparable</code>).<br />
</li>
<li>LinkedHashMap: Сохранение порядка вставки.</li>
</ul>
<h3 id="сортировка-коллекции">9. Сортировка коллекции</h3>
<ul>
<li><code>Collections.sort(list)</code> для <code>List</code>.<br />
</li>
<li><code>TreeSet</code>/<code>TreeMap</code> — автоматическая
сортировка.<br />
</li>
<li>Использование <code>Comparator</code> для кастомного порядка.</li>
</ul>
<h3 id="преимущество-массива-перед-arraylist">10. Преимущество массива
перед ArrayList</h3>
<ul>
<li>Производительность: Меньше накладных расходов.<br />
</li>
<li>Примитивы: Массивы поддерживают <code>int[]</code>,
<code>double[]</code> (без автоупаковки).<br />
</li>
<li>Фиксированный размер: Предсказуемое использование памяти.</li>
</ul>
<h2 id="class-object.-equals-and-hashcode">Class Object. Equals and
HashCode</h2>
<h3 id="class-object">1. Class Object</h3>
<p>Базовый класс всех объектов Java. Содержит методы:
<code>equals()</code>, <code>hashCode()</code>, <code>toString()</code>,
<code>clone()</code>, <code>finalize()</code>, <code>wait()</code>,
<code>notify()</code>, <code>notifyAll()</code>.</p>
<h3 id="equals-и-hashcode">2. Equals и HashCode</h3>
<ul>
<li><code>equals()</code>: Сравнение объектов на семантическое
равенство.<br />
</li>
<li><code>hashCode()</code>: Генерация хэш-кода для использования в
хэш-коллекциях (HashMap, HashSet).</li>
</ul>
<h3 id="контракт-между-equals-и-hashcode">3. Контракт между equals и
hashCode</h3>
<ul>
<li>Если <code>a.equals(b) == true</code>, то
<code>a.hashCode() == b.hashCode()</code>.<br />
</li>
<li>Обратное неверно: одинаковые хэши не гарантируют равенство
объектов.</li>
</ul>
<h3 id="условия-переопределения-equals">4. Условия переопределения
equals</h3>
<ul>
<li>Рефлексивность: <code>a.equals(a) == true</code>.<br />
</li>
<li>Симметричность: <code>a.equals(b) == b.equals(a)</code>.<br />
</li>
<li>Транзитивность: Если <code>a.equals(b)</code> и
<code>b.equals(c)</code>, то <code>a.equals(c)</code>.<br />
</li>
<li>Консистентность: Результат не должен меняться между вызовами.<br />
</li>
<li>Неравенство с <code>null</code>:
<code>a.equals(null) == false</code>.</li>
</ul>
<h3 id="если-не-переопределить-equalshashcode">5. Если не переопределить
equals/hashCode</h3>
<ul>
<li><code>equals()</code> сравнивает ссылки (<code>==</code>).<br />
</li>
<li><code>hashCode()</code> возвращает адрес в памяти (не подходит для
хэш-коллекций).</li>
</ul>
<h3 id="значения-без-переопределения">6. Значения без
переопределения</h3>
<ul>
<li><code>new Object().equals(new Object()) → false</code>.<br />
</li>
<li><code>new Object().hashCode() ≠ new Object().hashCode()</code>.</li>
</ul>
<h3 id="симметричность-и-equals">7. Симметричность и
<code>equals()</code></h3>
<p>Симметричность нарушится, если в <code>equals()</code> участвуют
разные классы. Пример:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span>  </span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="kw">extends</span> A <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span>  </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>a<span class="op">.</span><span class="fu">equals</span><span class="op">(</span>b<span class="op">)</span> → <span class="kw">true</span><span class="op">,</span> но b<span class="op">.</span><span class="fu">equals</span><span class="op">(</span>a<span class="op">)</span> → <span class="kw">false</span><span class="op">.</span>  </span></code></pre></div>
<h3 id="коллизия-hashcode">8. Коллизия hashCode</h3>
<p>Разные объекты имеют одинаковый хэш. Решения:</p>
<ul>
<li>Хороший алгоритм хэширования.<br />
</li>
<li>В HashMap: связные списки/деревья в бакетах.</li>
</ul>
<h3 id="изменение-объекта-в-hash-коллекции">9. Изменение объекта в
hash-коллекции</h3>
<p>Если объект изменен после добавления в коллекцию, его хэш может не
соответствовать бакету → коллекция становится некорректной.</p>
<h3 id="instanceof-vs-getclass">10. <code>instanceof</code> vs
<code>getClass()</code></h3>
<ul>
<li><code>instanceof</code>: Разрешает сравнение с подклассами (может
нарушить симметричность).<br />
</li>
<li><code>getClass()</code>: Строгая проверка класса (гарантирует
симметричность).</li>
</ul>
<h3 id="метод-clone">11. Метод clone()</h3>
<p>Создает копию объекта. Требует:</p>
<ul>
<li>Реализации <code>Cloneable</code>.<br />
</li>
<li>Глубокого копирования (если объект содержит изменяемые поля).<br />
</li>
<li>Переопределения с <code>public</code> доступом.</li>
</ul>
<h2 id="exceptions">Exceptions</h2>
<h3 id="определение-исключения-exception">1. Определение исключения
(exception)</h3>
<p>Исключение — событие, прерывающее нормальный поток выполнения
программы. Используется для обработки ошибок (ошибки ввода, деление на
ноль, доступ к null).</p>
<h3 id="особенности-trycatch">2. Особенности try…catch</h3>
<ul>
<li><code>try</code>: Блок с кодом, где может возникнуть
исключение.<br />
</li>
<li><code>catch</code>: Ловит указанный тип исключения. Можно несколько
<code>catch</code>.<br />
</li>
<li><code>finally</code>: Выполняется всегда (даже при исключении).</li>
</ul>
<h3 id="error-vs-exception">3. Error vs Exception</h3>
<ul>
<li>Error: Непроверяемые фатальные ошибки (OutOfMemoryError). Не
обрабатываются.<br />
</li>
<li>Exception: Проверяемые/непроверяемые ошибки, которые можно
обработать.</li>
</ul>
<h3 id="checked-vs-unchecked-throw-throws">4. Checked vs Unchecked,
throw, throws</h3>
<ul>
<li>Checked: Наследники <code>Exception</code> (кроме RuntimeException).
Требуют обработки.<br />
</li>
<li>Unchecked: Наследники <code>RuntimeException</code>.<br />
</li>
<li>throw: Выброс исключения
(<code>throw new IOException()</code>).<br />
</li>
<li>throws: Объявление исключений в сигнатуре метода.</li>
</ul>
<h3 id="иерархия-исключений">5. Иерархия исключений</h3>
<ul>
<li><code>Throwable</code> → <code>Error</code> (необрабатываемые) и
<code>Exception</code> (обрабатываемые).<br />
</li>
<li><code>Exception</code> → <code>RuntimeException</code> (unchecked) и
другие (checked).</li>
</ul>
<h3 id="checked-и-unchecked-исключения">6. Checked и Unchecked
исключения</h3>
<ul>
<li>Checked: Обязательны для обработки (try-catch/throws). Пример:
<code>IOException</code>.<br />
</li>
<li>Unchecked: Не требуют обработки. Пример:
<code>NullPointerException</code>.</li>
</ul>
<h3 id="проверка-checked-исключений">7. Проверка Checked исключений</h3>
<p>Да. Компилятор требует их обработки или объявления в
<code>throws</code>.</p>
<h3 id="ключевое-слово-throws">8. Ключевое слово throws</h3>
<p>Указывает, какие исключения метод может выбросить. Пример:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">readFile</span><span class="op">()</span> <span class="kw">throws</span> <span class="bu">IOException</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span>  </span></code></pre></div>
<h3 id="способы-обработки-исключений">9. Способы обработки
исключений</h3>
<ul>
<li><code>try-catch-finally</code>.<br />
</li>
<li>Проброс через <code>throws</code>.<br />
</li>
<li>Перехват в вызывающем коде.</li>
</ul>
<h3 id="правила-при-наследовании">10. Правила при наследовании</h3>
<p>Переопределяемый метод не может объявлять более общие checked
исключения, чем родительский.</p>
<h3 id="оператор-throw">11. Оператор throw</h3>
<p>Выбрасывает исключение:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">IllegalArgumentException</span><span class="op">();</span>  </span></code></pre></div>
<h3 id="метод-main-и-throws">12. Метод main и throws</h3>
<p>Да, может. Исключение передается в JVM, которая завершает программу и
печатает стектрейс.</p>
<h2 id="память-в-java">Память в Java</h2>
<h3 id="как-добиться-stackoverflowerror">1. Как добиться
StackOverflowError</h3>
<p>Бесконечная рекурсия:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">recursiveMethod</span><span class="op">()</span> <span class="op">{</span> <span class="fu">recursiveMethod</span><span class="op">();</span> <span class="op">}</span>  </span></code></pre></div>
<p>Причина: Переполнение стека вызовов (ограниченная память под
стек).</p>
<h3 id="outofmemoryerror-1">2. OutOfMemoryError</h3>
<ul>
<li>Heap-память: Создание множества объектов без возможности удаления
(например, бесконечный цикл с <code>new Object()</code>).<br />
</li>
<li>Metaspace/PermGen: Перегрузка классами (например, динамическая
генерация классов).</li>
</ul>
<h3 id="garbage-collector-gc">3. Garbage Collector (GC)</h3>
<p>Автоматически освобождает память от неиспользуемых объектов.<br />
Зачем: Управление памятью, предотвращение утечек.</p>
<h3 id="heap-vs-stack">4. Heap vs Stack</h3>
<ul>
<li>Heap: Область для хранения объектов (управляется GC).<br />
</li>
<li>Stack: Хранит локальные переменные, вызовы методов (примитивы,
ссылки). Работает по LIFO.</li>
</ul>
<h3 id="пул-строк-string-pool">5. Пул строк (String Pool)</h3>
<ul>
<li>Специальная область в Heap для уникальных строковых литералов.<br />
</li>
<li>Как работает:
<ul>
<li>При создании через литерал (<code>"text"</code>): проверка наличия в
пуле → возврат существующей строки.<br />
</li>
<li>При <code>new String("text")</code>: создается новый объект вне
пула.<br />
</li>
</ul></li>
<li>Цель: Оптимизация памяти за счет переиспользования строк.</li>
</ul>
<p>Пример:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> s1 <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span>        <span class="co">// Пул  </span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> s2 <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span>        <span class="co">// Существующий объект из пула  </span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> s3 <span class="op">=</span> <span class="kw">new</span> <span class="bu">String</span><span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">);</span> <span class="co">// Новый объект в Heap  </span></span></code></pre></div>
<h2 id="многопоточность">Многопоточность</h2>
<h3 id="процесс-и-поток">1. Процесс и поток</h3>
<ul>
<li>Процесс: Изолированный экземпляр программы с собственным адресным
пространством.<br />
</li>
<li>Поток (Thread): Легковесная единица выполнения внутри процесса.
Потоки разделяют память процесса.</li>
</ul>
<h3 id="многопоточность-в-java">2. Многопоточность в Java</h3>
<ul>
<li>Параллельное выполнение нескольких потоков для повышения
производительности.<br />
</li>
<li>Зачем: Распараллеливание задач (обработка запросов, асинхронные
операции).</li>
</ul>
<h3 id="создание-и-запуск-потока">3. Создание и запуск потока</h3>
<ul>
<li>Наследование от <code>Thread</code> и переопределение
<code>run()</code>.<br />
</li>
<li>Реализация <code>Runnable</code>/<code>Callable</code> и передача в
<code>Thread</code> или пул потоков.<br />
</li>
<li>Запуск: <code>thread.start()</code> (не <code>run()</code>!).</li>
</ul>
<h3 id="способы-синхронизации">4. Способы синхронизации</h3>
<ul>
<li><code>synchronized</code> блоки/методы.<br />
</li>
<li>Локи (<code>ReentrantLock</code>, <code>StampedLock</code>).<br />
</li>
<li>Атомарные классы (<code>AtomicInteger</code>,
<code>AtomicReference</code>).<br />
</li>
<li><code>volatile</code> переменные.</li>
</ul>
<h3 id="проблемы-многопоточности">5. Проблемы многопоточности</h3>
<ul>
<li>Состояние гонки (Race Condition).<br />
</li>
<li>Дэдлоки (Deadlock).<br />
</li>
<li>Голодание (Starvation).<br />
</li>
<li>Инверсия приоритетов.</li>
</ul>
<h3 id="race-condition">6. Race Condition</h3>
<ul>
<li>Непредсказуемый результат из-за конкуренции потоков за ресурс.<br />
</li>
<li>Предотвращение: Синхронизация, атомарные операции, неизменяемые
объекты.</li>
</ul>
<h3 id="deadlock">7. Deadlock</h3>
<ul>
<li>Взаимная блокировка потоков из-за ожидания ресурсов.<br />
</li>
<li>Избежание:
<ul>
<li>Упорядоченное получение локов.<br />
</li>
<li>Использование <code>tryLock()</code> с таймаутом.</li>
</ul></li>
</ul>
<h3 id="классы-и-интерфейсы">8. Классы и интерфейсы</h3>
<ul>
<li><code>Thread</code>, <code>Runnable</code>, <code>Callable</code>,
<code>Future</code>.<br />
</li>
<li><code>ExecutorService</code>, <code>ThreadPoolExecutor</code>,
<code>ForkJoinPool</code>.<br />
</li>
<li><code>Lock</code>, <code>Semaphore</code>,
<code>CountDownLatch</code>.</li>
</ul>
<h3 id="методы-синхронизации">9. Методы синхронизации</h3>
<ul>
<li><code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code>
(объекты мониторы).<br />
</li>
<li><code>Lock.lock()/unlock()</code>.<br />
</li>
<li><code>volatile</code> для видимости изменений между потоками.</li>
</ul>
<h3 id="пул-потоков-thread-pool">10. Пул потоков (Thread Pool)</h3>
<ul>
<li><p>Набор переиспользуемых потоков для выполнения задач.<br />
</p></li>
<li><p>Создание:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="bu">ExecutorService</span> pool <span class="op">=</span> <span class="bu">Executors</span><span class="op">.</span><span class="fu">newFixedThreadPool</span><span class="op">(</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>pool<span class="op">.</span><span class="fu">submit</span><span class="op">(()</span> <span class="op">-&gt;</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">});</span></span></code></pre></div></li>
</ul>
<h3 id="forkjoinpool">11. ForkJoinPool</h3>
<ul>
<li>Специализированный пул для рекурсивных задач (разделяй и
властвуй).<br />
</li>
<li>Особенности:
<ul>
<li>Работает через <code>ForkJoinTask</code> (например,
<code>RecursiveTask</code>).<br />
</li>
<li>Использует алгоритм “work-stealing” для балансировки нагрузки.</li>
</ul></li>
</ul>
</body>
</html>
