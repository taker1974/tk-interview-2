<?xml version="1.0" encoding="UTF-8"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink"><description><title-info><genre>unrecognised</genre><book-title>Вопросы для подготовки</book-title></title-info><document-info><program-used>pandoc</program-used></document-info></description><body><title><p>Вопросы для подготовки</p></title><section id="вопросы-для-подготовки"><title><p>Вопросы для подготовки</p></title><section id="java-core"><title><p>Java Core</p></title><section id="типы-данных-в-java"><title><p>1. Типы данных в Java</p></title><p>• Примитивные: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code>, <code>boolean</code>.
</p><p>• Объектные (ссылочные): Все классы (включая <code>String</code>, массивы, пользовательские классы).</p></section><section id="объектные-vs-примитивные-типы"><title><p>2. Объектные vs примитивные типы</p></title><p>• Примитивные хранят значение, объектные — ссылки.
</p><p>• Примитивные не могут быть <code>null</code>, имеют значения по умолчанию (например, <code>0</code>).
</p><p>• Объектные требуют больше памяти, поддерживают методы.</p></section><section id="передача-параметров"><title><p>3. Передача параметров</p></title><p>• В Java всегда передача по значению:</p><p>• • Для примитивов — копия значения.
</p><p>• • Для объектов — копия ссылки (изменения внутри метода влияют на объект).</p></section><section id="outofmemoryerror"><title><p>4. OutOfMemoryError</p></title><p>• Ошибка при нехватке памяти в heap.
</p><p>• Причины: утечки памяти, большие структуры данных.
</p><p>• Диагностика: профилировщики (VisualVM, MAT).</p></section><section id="стектрейс"><title><p>5. Стектрейс</p></title><p>• Цепочка вызовов методов до точки ошибки.
</p><p>• Получить: <code>e.printStackTrace()</code> или <code>Thread.currentThread().getStackTrace()</code>.</p></section><section id="методы-класса-object"><title><p>6. Методы класса Object</p></title><p>• <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code>, <code>clone()</code>, <code>getClass()</code>, <code>finalize()</code>, <code>notify()</code>, <code>notifyAll()</code>, <code>wait()</code> (3 перегрузки).</p></section><section id="конструкторы"><title><p>7. Конструкторы</p></title><p>• Специальные методы для инициализации объекта.
</p><p>• Типы: по умолчанию (без параметров), параметризованные, приватные (для singleton), копирования.</p></section><section id="immutable-стандартные-классы"><title><p>8. Immutable стандартные классы</p></title><p>• <code>String</code>, <code>Integer</code>, <code>Double</code>, <code>LocalDate</code>, <code>BigDecimal</code>, <code>Duration</code>, <code>UUID</code>.</p></section><section id="immutable-объекты"><title><p>9. Immutable объекты</p></title><p>• Характеристика: Состояние не меняется после создания.
</p><p>• Зачем: Безопасность в многопоточности, предсказуемость.
</p><p>• Создать: <code>final</code> класс + поля, отсутствие сеттеров, возврат копий в геттерах.
</p><p>• Преимущества: Потокобезопасность, простота кэширования, отсутствие side-эффектов.</p></section></section><section id="ооп"><title><p>ООП</p></title><section id="ооп-1"><title><p>1. ООП</p></title><p>Парадигма программирования, основанная на объектах. Принципы:</p><p>• Инкапсуляция (скрытие данных: <code>private</code> поля + геттеры/сеттеры).
</p><p>• Наследование (<code>class Dog extends Animal</code>).
</p><p>• Полиморфизм (перегрузка/переопределение методов).
</p><p>• Абстракция (интерфейсы, абстрактные классы).</p></section><section id="наследование"><title><p>2. Наследование</p></title><p>Позволяет классу (потомку) использовать поля/методы другого класса (родителя). Пример: <code>class ElectricCar extends Car</code>.
Зачем: Повторное использование кода, иерархия.</p></section><section id="полиморфизм"><title><p>3. Полиморфизм</p></title><p>Обращение к объектам разных классов через общий интерфейс. Работает через:</p><p>• Переопределение методов (<code>@Override</code>).
</p><p>• Перегрузку методов (разные сигнатуры).
Пример: <code>List&lt;String&gt; list = new ArrayList&lt;&gt;()</code>.</p></section><section id="абстракция"><title><p>4. Абстракция</p></title><p>Сокрытие сложности через интерфейсы/абстрактные классы. Пример: <code>interface Shape</code> с методом <code>draw()</code>.</p></section><section id="инкапсуляция"><title><p>5. Инкапсуляция</p></title><p>• Модификаторы доступа (<code>private</code>, <code>protected</code>).
</p><p>• Геттеры/сеттеры.
</p><p>• Класс как капсула данных и методов.</p></section><section id="наследование-в-java"><title><p>6. Наследование в Java</p></title><p>• Ключевое слово <code>extends</code>.
</p><p>• <code>super</code>: вызов конструктора/метода родителя (<code>super()</code> или <code>super.method()</code>).</p></section><section id="полиморфизм-в-java"><title><p>7. Полиморфизм в Java</p></title><p>• Переопределение методов (<code>@Override</code>).
</p><p>• Интерфейсы (<code>implements</code>).
</p><p>• Перегрузка методов (разные параметры).</p></section><section id="перегрузка-overloading"><title><p>8. Перегрузка (overloading)</p></title><p>Методы с одинаковым именем, но разными параметрами. Пример:</p><empty-line /><p><code>void print(int x) { ... }  </code></p><p><code>void print(String s) { ... }  </code></p><empty-line /></section><section id="переопределение-override"><title><p>9. Переопределение (override)</p></title><p>Изменение реализации метода в подклассе. Пример:</p><empty-line /><p><code>@Override  </code></p><p><code>public String toString() { ... }  </code></p><empty-line /></section><section id="класс-объект-интерфейс"><title><p>10. Класс, объект, интерфейс</p></title><p>• Класс: Шаблон для создания объектов.
</p><p>• Объект: Экземпляр класса.
</p><p>• Интерфейс: Контракт методов (<code>interface Runnable</code>).</p></section><section id="элементы-класса"><title><p>11. Элементы класса</p></title><p>Поля, методы, конструкторы, вложенные классы, блоки инициализации.</p></section><section id="сигнатура-метода"><title><p>12. Сигнатура метода</p></title><p>Имя метода + типы/порядок параметров. Пример: <code>add(int a, int b)</code>.</p></section><section id="return-в-конструкторе"><title><p>13. return в конструкторе</p></title><p>Да, можно использовать <code>return;</code> для завершения, но нельзя возвращать значение.</p></section><section id="исключения-в-конструкторе"><title><p>14. Исключения в конструкторе</p></title><p>Да, можно. Пример:</p><empty-line /><p><code>public MyClass() throws IOException { ... }  </code></p><empty-line /></section><section id="ключевое-слово-this"><title><p>15. Ключевое слово this</p></title><p>• Разрешение конфликта имен (поля vs параметры).
</p><p>• Вызов других конструкторов (<code>this()</code>).</p></section><section id="модификаторы-доступа"><title><p>16. Модификаторы доступа</p></title><p>• <code>public</code>: Доступ везде.
</p><p>• <code>protected</code>: Тот же пакет + подклассы.
</p><p>• <code>private</code>: Только внутри класса.
</p><p>• По умолчанию: Тот же пакет.</p></section><section id="статические-переменныеметоды"><title><p>17. Статические переменные/методы</p></title><p>• Принадлежат классу, а не объекту.
</p><p>• Ограничения: Не могут использовать <code>this</code>, обращаться к нестатическим полям/методам напрямую.</p></section><section id="ключевое-слово-static"><title><p>18. Ключевое слово static</p></title><p>• Статический метод можно перегрузить, но нельзя переопределить.</p></section><section id="использование-static-методов"><title><p>19. Использование static методов</p></title><p>• Статические методы можно вызывать из обычных (через имя класса).
</p><p>• Обычные методы нельзя вызвать из статических без объекта.</p></section><section id="final"><title><p>20. final</p></title><p>• Поля: Неизменяемые после инициализации.
</p><p>• Классы: Запрет наследования.
</p><p>• Методы: Запрет переопределения.</p></section><section id="abstract"><title><p>21. abstract</p></title><p>• Абстрактный класс: Нельзя создать объект.
</p><p>• Абстрактный метод: Без реализации (должен быть переопределен).</p></section><section id="interface"><title><p>22. interface</p></title><p>Контракт методов. Не может быть <code>final</code> (должен быть реализован).</p></section><section id="абстрактный-класс-vs-интерфейс"><title><p>23. Абстрактный класс vs интерфейс</p></title><p>• Абстрактный класс: Поля, конструкторы, реализация методов.
</p><p>• Интерфейс: Только абстрактные методы (до Java 8), константы.</p></section><section id="модификаторы-доступа-класса"><title><p>24. Модификаторы доступа класса</p></title><p>• <code>public</code>: Доступ везде.
</p><p>• Без модификатора (package-private): Только в том же пакете.</p></section></section><section id="string"><title><p>String</p></title><section id="класс-string-в-java"><title><p>1. Класс String в Java</p></title><p>• Неизменяемый (immutable) класс для работы с последовательностями символов.
</p><p>• Реализует интерфейсы <code>CharSequence</code>, <code>Serializable</code>, <code>Comparable&lt;String&gt;</code>.
</p><p>• Хранится в куче (heap), но с оптимизацией через строковый пул (String Pool).</p></section><section id="способы-создания-string"><title><p>2. Способы создания String</p></title><p>• Литерал: <code>String s = &quot;text&quot;;</code> (попадает в String Pool).
</p><p>• Через конструктор: <code>new String(&quot;text&quot;)</code> (создает новый объект в куче).
</p><p>• Из массива символов: <code>new char[] {&#39;t&#39;,&#39;e&#39;,&#39;x&#39;,&#39;t&#39;}</code>.
</p><p>• Через <code>StringBuilder</code>/<code>StringBuffer</code>: <code>new StringBuilder().toString()</code>.</p></section><section id="сравнение-и-сортировка-строк"><title><p>3. Сравнение и сортировка строк</p></title><p>• <code>==</code>: Сравнивает ссылки, а не содержимое.
</p><p>• <code>equals()</code>: Сравнивает содержимое строк.
</p><p>• <code>compareTo()</code>: Для сортировки (возвращает разницу в Unicode).
</p><p>• <code>Arrays.sort()</code> или <code>Collections.sort()</code> с компаратором.</p></section><section id="строковый-пул-string-pool"><title><p>4. Строковый пул (String Pool)</p></title><p>• Специальная область в heap для хранения уникальных строковых литералов.
</p><p>• Цель: Экономия памяти за счет переиспользования строк.
</p><p>• При создании через литерал (<code>&quot;text&quot;</code>) JVM сначала проверяет String Pool.</p></section><section id="string-vs-stringbuffer-vs-stringbuilder"><title><p>5. String vs StringBuffer vs StringBuilder</p></title><p>• String: Неизменяемый. Подходит для констант, ключей в <code>HashMap</code>.
</p><p>• StringBuffer: Изменяемый, потокобезопасный (синхронизированные методы).
</p><p>• StringBuilder: Изменяемый, не потокобезопасный, быстрее StringBuffer.
</p><p>• Использовать:</p><p>• • <code>String</code> для редко меняющихся данных.
</p><p>• • <code>StringBuilder</code> для однопоточных операций.
</p><p>• • <code>StringBuffer</code> для многопоточных.</p></section><section id="примеры"><title><p>Примеры</p></title><empty-line /><p><code>// Создание строк</code></p><p><code>String s1 = &quot;Hello&quot;;        // String Pool</code></p><p><code>String s2 = new String(&quot;Hello&quot;); // Heap</code></p><p><code></code></p><p><code>// Сравнение</code></p><p><code>boolean isEqual = s1.equals(s2); // true</code></p><p><code></code></p><p><code>// StringBuilder</code></p><p><code>StringBuilder sb = new StringBuilder();</code></p><p><code>sb.append(&quot;Hello&quot;).append(&quot; World&quot;);</code></p><p><code>String result = sb.toString(); // &quot;Hello World&quot;</code></p><empty-line /></section></section><section id="enum"><title><p>Enum</p></title><section id="краткая-характеристика-enum"><title><p>1. Краткая характеристика Enum</p></title><p>• Тип данных для фиксированного набора констант (безопасная замена <code>int</code>/<code>String</code> констант).
</p><p>• Может содержать поля, методы, конструкторы.
</p><p>• Неявно наследуется от <code>java.lang.Enum</code>.</p></section><section id="реализация-интерфейса"><title><p>2. Реализация интерфейса</p></title><p>Да. Пример:</p><empty-line /><p><code>interface Loggable { void log(); }  </code></p><p><code>enum Status implements Loggable {  </code></p><p><code>  ACTIVE { public void log() { ... } },  </code></p><p><code>  INACTIVE { public void log() { ... } }  </code></p><p><code>}  </code></p><empty-line /></section><section id="наследование-extends"><title><p>3. Наследование (extends)</p></title><p>Нет. Enum не может наследовать классы (кроме неявного наследования от <code>java.lang.Enum</code>).</p></section><section id="enum-без-экземпляров"><title><p>4. Enum без экземпляров</p></title><p>Нет. Должен содержать минимум одну константу.</p></section><section id="переопределение-tostring"><title><p>5. Переопределение <code>toString()</code></p></title><p>Да. Пример:</p><empty-line /><p><code>enum Color { RED { public String toString() { return &quot;Красный&quot;; } }  </code></p><empty-line /></section><section id="поведение-tostring-по-умолчанию"><title><p>6. Поведение <code>toString()</code> по умолчанию</p></title><p>Возвращает имя константы (например, <code>RED</code> для <code>Color.RED</code>).</p></section><section id="конструктор-в-enum"><title><p>7. Конструктор в Enum</p></title><p>Да. Конструктор должен быть <code>private</code>:</p><empty-line /><p><code>enum Size { SMALL(10), MEDIUM(20);  </code></p><p><code>  private int value;  </code></p><p><code>  private Size(int value) { this.value = value; }  </code></p><p><code>}  </code></p><empty-line /></section><section id="vs-equals"><title><p>8. <code>==</code> vs <code>equals()</code></p></title><p>• <code>==</code> сравнивает ссылки (безопасно, т.к. константы уникальны).
</p><p>• <code>equals()</code> вызывает <code>==</code> под капотом.</p></section><section id="метод-ordinal"><title><p>9. Метод <code>ordinal()</code></p></title><p>• Возвращает порядковый номер константы (начинается с 0).
</p><p>• Пример: <code>Color.RED.ordinal()</code> → 0.</p></section><section id="enum-в-treesettreemap"><title><p>10. Enum в <code>TreeSet</code>/<code>TreeMap</code></p></title><p>• Да. Сортировка по <code>natural order</code> (порядок объявления констант).</p></section><section id="связь-ordinal-и-compareto"><title><p>11. Связь <code>ordinal()</code> и <code>compareTo()</code></p></title><p>• <code>compareTo()</code> использует <code>ordinal()</code> для сравнения.</p></section><section id="enum-в-switch-case"><title><p>12. Enum в <code>switch case</code></p></title><p>• Да. Пример:</p><empty-line /><empty-line /><p><code>  switch (color) {  </code></p><p><code>    case RED: ... break;  </code></p><p><code>    case BLUE: ... break;  </code></p><p><code>  }  </code></p><empty-line /></section><section id="получение-всех-значений-enum"><title><p>13. Получение всех значений Enum</p></title><p>• Метод <code>values()</code>:</p><empty-line /><empty-line /><p><code>  Color[] colors = Color.values(); // [RED, GREEN, BLUE]  </code></p><empty-line /></section></section><section id="фунциональные-интерфейсы"><title><p>Фунциональные интерфейсы</p></title><section id="функциональный-интерфейс"><title><p>1. Функциональный интерфейс</p></title><p>• Интерфейс с одним абстрактным методом (SAM).
</p><p>• Может иметь <code>default</code>/<code>static</code> методы.
</p><p>• Аннотация <code>@FunctionalInterface</code> (проверяет условие на этапе компиляции).
</p><p>• Пример: <code>Runnable</code>, <code>Comparator</code>.</p></section><section id="стандартные-функциональные-интерфейсы"><title><p>2. Стандартные функциональные интерфейсы</p></title><p>• <code>Predicate&lt;T&gt;</code>: Проверяет условие (<code>test(T t)</code> → <code>boolean</code>).
</p><p>• <code>Function&lt;T,R&gt;</code>: Преобразует <code>T</code> в <code>R</code> (<code>apply(T t)</code> → <code>R</code>).
</p><p>• <code>Consumer&lt;T&gt;</code>: Принимает <code>T</code>, ничего не возвращает (<code>accept(T t)</code>).
</p><p>• <code>Supplier&lt;T&gt;</code>: Поставляет значение (<code>get()</code> → <code>T</code>).
</p><p>• <code>UnaryOperator&lt;T&gt;</code>: <code>Function&lt;T,T&gt;</code> (например, <code>x -&gt; x + 1</code>).
</p><p>• <code>BinaryOperator&lt;T&gt;</code>: Принимает два <code>T</code>, возвращает <code>T</code> (например, <code>(a, b) -&gt; a + b</code>).</p></section><section id="лямбда-выражение"><title><p>3. Лямбда-выражение</p></title><p>• Анонимная функция, реализующая метод функционального интерфейса.
</p><empty-line /><p>• Синтаксис: <code>(параметры) -&gt; { тело }</code>.
</p><empty-line /><p>• Пример:</p><empty-line /><empty-line /><p><code>  Function&lt;Integer, Integer&gt; square = x -&gt; x * x;</code></p><empty-line /></section><section id="ссылка-на-метод"><title><p>4. Ссылка на метод (<code>::</code>)</p></title><p>• Сокращенная запись для вызова существующего метода.
</p><empty-line /><p>• Типы:</p><empty-line /><p>• • Статический метод: <code>ClassName::method</code>.
</p><p>• • Метод экземпляра: <code>instance::method</code> или <code>ClassName::method</code> (нестатический).
</p><p>• • Конструктор: <code>ClassName::new</code>.
</p><p>• Отличие от лямбды: Не создает новую реализацию, а ссылается на существующий метод.
</p><empty-line /><p>• Пример:</p><empty-line /><empty-line /><p><code>  Consumer&lt;String&gt; printer = System.out::println;</code></p><empty-line /></section></section><section id="stream-api"><title><p>Stream API</p></title><section id="stream-api-в-java"><title><p>1. Stream API в Java</p></title><p>Интерфейс для обработки коллекций/данных в функциональном стиле. Позволяет выполнять операции (фильтрация, преобразование, агрегация) цепочкой. Не изменяет исходные данные.</p></section><section id="создание-stream-из-коллекции"><title><p>2. Создание Stream из коллекции</p></title><p>• <code>collection.stream()</code>: Создает последовательный стрим.
</p><p>• <code>collection.parallelStream()</code>: Создает параллельный стрим.
</p><p>• <code>Stream.of(...)</code>, <code>Arrays.stream(array)</code>: Для массивов/наборов элементов.</p></section><section id="промежуточные-операции"><title><p>3. Промежуточные операции</p></title><p>Операции, возвращающие новый Stream (ленивые, выполняются при вызове терминальной операции). Примеры:</p><p>• <code>filter(Predicate)</code>: Фильтрация элементов.
</p><p>• <code>map(Function)</code>: Преобразование элементов.
</p><p>• <code>sorted()</code>, <code>distinct()</code>, <code>limit(n)</code>.</p></section><section id="терминальные-операции"><title><p>4. Терминальные операции</p></title><p>Завершают обработку Stream, возвращают результат (число, коллекцию и т.д.). Примеры:</p><p>• <code>collect(Collectors.toList())</code>: Сохранение в коллекцию.
</p><p>• <code>forEach(Consumer)</code>: Выполнение действия для каждого элемента.
</p><p>• <code>reduce()</code>, <code>count()</code>, <code>min()</code>, <code>max()</code>.</p></section><section id="параллельные-стримы"><title><p>5. Параллельные стримы</p></title><p>Обработка элементов в нескольких потоках. Создается через <code>parallelStream()</code>. Требует осторожности с потокобезопасностью.</p></section><section id="группировка-элементов"><title><p>6. Группировка элементов</p></title><p>• <code>Collectors.groupingBy(Function)</code>: Группировка по ключу.
</p><p>• <code>Collectors.partitioningBy(Predicate)</code>: Разделение на <code>true</code>/<code>false</code>.</p></section><section id="метод-filter"><title><p>7. Метод <code>filter</code></p></title><p>Принимает <code>Predicate&lt;T&gt;</code> (функцию, возвращающую <code>boolean</code>). Пример:</p><empty-line /><p><code>list.stream().filter(s -&gt; s.length() &gt; 3)  </code></p><empty-line /></section><section id="дополнение"><title><p>Дополнение</p></title><p>• Ленивые вычисления: Промежуточные операции выполняются только при вызове терминальной.
</p><p>• Порядок операций: Влияет на производительность (например, <code>filter</code> перед <code>map</code>).</p></section></section><section id="collections"><title><p>Collections</p></title><section id="иерархия-коллекций"><title><p>1. Иерархия коллекций</p></title><p>• Интерфейсы: <code>Collection</code> → <code>List</code>, <code>Set</code>, <code>Queue</code>; <code>Map</code> (отдельная иерархия).
</p><p>• Реализации: <code>List</code> → <code>ArrayList</code>, <code>LinkedList</code>; <code>Set</code> → <code>HashSet</code>, <code>TreeSet</code>; <code>Map</code> → <code>HashMap</code>, <code>TreeMap</code>.</p></section><section id="внутреннее-строение-arraylist"><title><p>2. Внутреннее строение ArrayList</p></title><p>• Динамический массив (<code>Object[]</code>).
</p><p>• Начальная ёмкость: 10. При заполнении увеличивается на 50% (<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>).</p></section><section id="внутреннее-строение-linkedlist"><title><p>3. Внутреннее строение LinkedList</p></title><p>• Двусвязный список: каждый элемент (<code>Node</code>) содержит ссылки на предыдущий и следующий узлы.
</p><p>• Нет необходимости в увеличении ёмкости, но больше памяти на ссылки.</p></section><section id="внутреннее-строение-hashmap"><title><p>4. Внутреннее строение HashMap</p></title><p>• Массив бакетов (по умолчанию: 16).
</p><p>• Каждый бакет — связный список или сбалансированное дерево (при коллизиях, Java 8+).
</p><p>• Хэш-функция: <code>hashCode()</code> ключа → индекс бакета.</p></section><section id="arraylist-vs-linkedlist"><title><p>5. ArrayList vs LinkedList</p></title><p>• ArrayList: Быстрый доступ по индексу (<code>O(1)</code>), медленные вставка/удаление в середине (<code>O(n)</code>).
</p><p>• LinkedList: Медленный доступ по индексу (<code>O(n)</code>), быстрые вставка/удаление (<code>O(1)</code>).</p></section><section id="arraylist-vs-hashset"><title><p>6. ArrayList vs HashSet</p></title><p>• ArrayList: Дубликаты разрешены, порядок элементов сохраняется.
</p><p>• HashSet: Дубликаты запрещены, порядок не гарантирован.</p></section><section id="многообразие-динамических-массивов"><title><p>7. Многообразие динамических массивов</p></title><p>• Разные требования:</p><p>• • <code>ArrayList</code> — для быстрого доступа.
</p><p>• • <code>Vector</code> — потокобезопасная версия.
</p><p>• • <code>CopyOnWriteArrayList</code> — для многопоточности.</p></section><section id="многообразие-key-value-storage"><title><p>8. Многообразие key-value storage</p></title><p>• HashMap: Быстрый доступ, порядок не гарантирован.
</p><p>• TreeMap: Сортировка по ключам (<code>Comparable</code>).
</p><p>• LinkedHashMap: Сохранение порядка вставки.</p></section><section id="сортировка-коллекции"><title><p>9. Сортировка коллекции</p></title><p>• <code>Collections.sort(list)</code> для <code>List</code>.
</p><p>• <code>TreeSet</code>/<code>TreeMap</code> — автоматическая сортировка.
</p><p>• Использование <code>Comparator</code> для кастомного порядка.</p></section><section id="преимущество-массива-перед-arraylist"><title><p>10. Преимущество массива перед ArrayList</p></title><p>• Производительность: Меньше накладных расходов.
</p><p>• Примитивы: Массивы поддерживают <code>int[]</code>, <code>double[]</code> (без автоупаковки).
</p><p>• Фиксированный размер: Предсказуемое использование памяти.</p></section></section><section id="class-object.-equals-and-hashcode"><title><p>Class Object. Equals and HashCode</p></title><section id="class-object"><title><p>1. Class Object</p></title><p>Базовый класс всех объектов Java. Содержит методы: <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code>, <code>clone()</code>, <code>finalize()</code>, <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code>.</p></section><section id="equals-и-hashcode"><title><p>2. Equals и HashCode</p></title><p>• <code>equals()</code>: Сравнение объектов на семантическое равенство.
</p><p>• <code>hashCode()</code>: Генерация хэш-кода для использования в хэш-коллекциях (HashMap, HashSet).</p></section><section id="контракт-между-equals-и-hashcode"><title><p>3. Контракт между equals и hashCode</p></title><p>• Если <code>a.equals(b) == true</code>, то <code>a.hashCode() == b.hashCode()</code>.
</p><p>• Обратное неверно: одинаковые хэши не гарантируют равенство объектов.</p></section><section id="условия-переопределения-equals"><title><p>4. Условия переопределения equals</p></title><p>• Рефлексивность: <code>a.equals(a) == true</code>.
</p><p>• Симметричность: <code>a.equals(b) == b.equals(a)</code>.
</p><p>• Транзитивность: Если <code>a.equals(b)</code> и <code>b.equals(c)</code>, то <code>a.equals(c)</code>.
</p><p>• Консистентность: Результат не должен меняться между вызовами.
</p><p>• Неравенство с <code>null</code>: <code>a.equals(null) == false</code>.</p></section><section id="если-не-переопределить-equalshashcode"><title><p>5. Если не переопределить equals/hashCode</p></title><p>• <code>equals()</code> сравнивает ссылки (<code>==</code>).
</p><p>• <code>hashCode()</code> возвращает адрес в памяти (не подходит для хэш-коллекций).</p></section><section id="значения-без-переопределения"><title><p>6. Значения без переопределения</p></title><p>• <code>new Object().equals(new Object()) → false</code>.
</p><p>• <code>new Object().hashCode() ≠ new Object().hashCode()</code>.</p></section><section id="симметричность-и-equals"><title><p>7. Симметричность и <code>equals()</code></p></title><p>Симметричность нарушится, если в <code>equals()</code> участвуют разные классы. Пример:</p><empty-line /><p><code>class A { ... }  </code></p><p><code>class B extends A { ... }  </code></p><p><code>a.equals(b) → true, но b.equals(a) → false.  </code></p><empty-line /></section><section id="коллизия-hashcode"><title><p>8. Коллизия hashCode</p></title><p>Разные объекты имеют одинаковый хэш. Решения:</p><p>• Хороший алгоритм хэширования.
</p><p>• В HashMap: связные списки/деревья в бакетах.</p></section><section id="изменение-объекта-в-hash-коллекции"><title><p>9. Изменение объекта в hash-коллекции</p></title><p>Если объект изменен после добавления в коллекцию, его хэш может не соответствовать бакету → коллекция становится некорректной.</p></section><section id="instanceof-vs-getclass"><title><p>10. <code>instanceof</code> vs <code>getClass()</code></p></title><p>• <code>instanceof</code>: Разрешает сравнение с подклассами (может нарушить симметричность).
</p><p>• <code>getClass()</code>: Строгая проверка класса (гарантирует симметричность).</p></section><section id="метод-clone"><title><p>11. Метод clone()</p></title><p>Создает копию объекта. Требует:</p><p>• Реализации <code>Cloneable</code>.
</p><p>• Глубокого копирования (если объект содержит изменяемые поля).
</p><p>• Переопределения с <code>public</code> доступом.</p></section></section><section id="exceptions"><title><p>Exceptions</p></title><section id="определение-исключения-exception"><title><p>1. Определение исключения (exception)</p></title><p>Исключение — событие, прерывающее нормальный поток выполнения программы. Используется для обработки ошибок (ошибки ввода, деление на ноль, доступ к null).</p></section><section id="особенности-trycatch"><title><p>2. Особенности try…catch</p></title><p>• <code>try</code>: Блок с кодом, где может возникнуть исключение.
</p><p>• <code>catch</code>: Ловит указанный тип исключения. Можно несколько <code>catch</code>.
</p><p>• <code>finally</code>: Выполняется всегда (даже при исключении).</p></section><section id="error-vs-exception"><title><p>3. Error vs Exception</p></title><p>• Error: Непроверяемые фатальные ошибки (OutOfMemoryError). Не обрабатываются.
</p><p>• Exception: Проверяемые/непроверяемые ошибки, которые можно обработать.</p></section><section id="checked-vs-unchecked-throw-throws"><title><p>4. Checked vs Unchecked, throw, throws</p></title><p>• Checked: Наследники <code>Exception</code> (кроме RuntimeException). Требуют обработки.
</p><p>• Unchecked: Наследники <code>RuntimeException</code>.
</p><p>• throw: Выброс исключения (<code>throw new IOException()</code>).
</p><p>• throws: Объявление исключений в сигнатуре метода.</p></section><section id="иерархия-исключений"><title><p>5. Иерархия исключений</p></title><p>• <code>Throwable</code> → <code>Error</code> (необрабатываемые) и <code>Exception</code> (обрабатываемые).
</p><p>• <code>Exception</code> → <code>RuntimeException</code> (unchecked) и другие (checked).</p></section><section id="checked-и-unchecked-исключения"><title><p>6. Checked и Unchecked исключения</p></title><p>• Checked: Обязательны для обработки (try-catch/throws). Пример: <code>IOException</code>.
</p><p>• Unchecked: Не требуют обработки. Пример: <code>NullPointerException</code>.</p></section><section id="проверка-checked-исключений"><title><p>7. Проверка Checked исключений</p></title><p>Да. Компилятор требует их обработки или объявления в <code>throws</code>.</p></section><section id="ключевое-слово-throws"><title><p>8. Ключевое слово throws</p></title><p>Указывает, какие исключения метод может выбросить. Пример:</p><empty-line /><p><code>void readFile() throws IOException { ... }  </code></p><empty-line /></section><section id="способы-обработки-исключений"><title><p>9. Способы обработки исключений</p></title><p>• <code>try-catch-finally</code>.
</p><p>• Проброс через <code>throws</code>.
</p><p>• Перехват в вызывающем коде.</p></section><section id="правила-при-наследовании"><title><p>10. Правила при наследовании</p></title><p>Переопределяемый метод не может объявлять более общие checked исключения, чем родительский.</p></section><section id="оператор-throw"><title><p>11. Оператор throw</p></title><p>Выбрасывает исключение:</p><empty-line /><p><code>if (x &lt; 0) throw new IllegalArgumentException();  </code></p><empty-line /></section><section id="метод-main-и-throws"><title><p>12. Метод main и throws</p></title><p>Да, может. Исключение передается в JVM, которая завершает программу и печатает стектрейс.</p></section></section><section id="память-в-java"><title><p>Память в Java</p></title><section id="как-добиться-stackoverflowerror"><title><p>1. Как добиться StackOverflowError</p></title><p>Бесконечная рекурсия:</p><empty-line /><p><code>void recursiveMethod() { recursiveMethod(); }  </code></p><empty-line /><p>Причина: Переполнение стека вызовов (ограниченная память под стек).</p></section><section id="outofmemoryerror-1"><title><p>2. OutOfMemoryError</p></title><p>• Heap-память: Создание множества объектов без возможности удаления (например, бесконечный цикл с <code>new Object()</code>).
</p><p>• Metaspace/PermGen: Перегрузка классами (например, динамическая генерация классов).</p></section><section id="garbage-collector-gc"><title><p>3. Garbage Collector (GC)</p></title><p>Автоматически освобождает память от неиспользуемых объектов.
Зачем: Управление памятью, предотвращение утечек.</p></section><section id="heap-vs-stack"><title><p>4. Heap vs Stack</p></title><p>• Heap: Область для хранения объектов (управляется GC).
</p><p>• Stack: Хранит локальные переменные, вызовы методов (примитивы, ссылки). Работает по LIFO.</p></section><section id="пул-строк-string-pool"><title><p>5. Пул строк (String Pool)</p></title><p>• Специальная область в Heap для уникальных строковых литералов.
</p><p>• Как работает:</p><p>• • При создании через литерал (<code>&quot;text&quot;</code>): проверка наличия в пуле → возврат существующей строки.
</p><p>• • При <code>new String(&quot;text&quot;)</code>: создается новый объект вне пула.
</p><p>• Цель: Оптимизация памяти за счет переиспользования строк.</p><p>Пример:</p><empty-line /><p><code>String s1 = &quot;hello&quot;;        // Пул  </code></p><p><code>String s2 = &quot;hello&quot;;        // Существующий объект из пула  </code></p><p><code>String s3 = new String(&quot;hello&quot;); // Новый объект в Heap  </code></p><empty-line /></section></section><section id="многопоточность"><title><p>Многопоточность</p></title><section id="процесс-и-поток"><title><p>1. Процесс и поток</p></title><p>• Процесс: Изолированный экземпляр программы с собственным адресным пространством.
</p><p>• Поток (Thread): Легковесная единица выполнения внутри процесса. Потоки разделяют память процесса.</p></section><section id="многопоточность-в-java"><title><p>2. Многопоточность в Java</p></title><p>• Параллельное выполнение нескольких потоков для повышения производительности.
</p><p>• Зачем: Распараллеливание задач (обработка запросов, асинхронные операции).</p></section><section id="создание-и-запуск-потока"><title><p>3. Создание и запуск потока</p></title><p>• Наследование от <code>Thread</code> и переопределение <code>run()</code>.
</p><p>• Реализация <code>Runnable</code>/<code>Callable</code> и передача в <code>Thread</code> или пул потоков.
</p><p>• Запуск: <code>thread.start()</code> (не <code>run()</code>!).</p></section><section id="способы-синхронизации"><title><p>4. Способы синхронизации</p></title><p>• <code>synchronized</code> блоки/методы.
</p><p>• Локи (<code>ReentrantLock</code>, <code>StampedLock</code>).
</p><p>• Атомарные классы (<code>AtomicInteger</code>, <code>AtomicReference</code>).
</p><p>• <code>volatile</code> переменные.</p></section><section id="проблемы-многопоточности"><title><p>5. Проблемы многопоточности</p></title><p>• Состояние гонки (Race Condition).
</p><p>• Дэдлоки (Deadlock).
</p><p>• Голодание (Starvation).
</p><p>• Инверсия приоритетов.</p></section><section id="race-condition"><title><p>6. Race Condition</p></title><p>• Непредсказуемый результат из-за конкуренции потоков за ресурс.
</p><p>• Предотвращение: Синхронизация, атомарные операции, неизменяемые объекты.</p></section><section id="deadlock"><title><p>7. Deadlock</p></title><p>• Взаимная блокировка потоков из-за ожидания ресурсов.
</p><p>• Избежание:</p><p>• • Упорядоченное получение локов.
</p><p>• • Использование <code>tryLock()</code> с таймаутом.</p></section><section id="классы-и-интерфейсы"><title><p>8. Классы и интерфейсы</p></title><p>• <code>Thread</code>, <code>Runnable</code>, <code>Callable</code>, <code>Future</code>.
</p><p>• <code>ExecutorService</code>, <code>ThreadPoolExecutor</code>, <code>ForkJoinPool</code>.
</p><p>• <code>Lock</code>, <code>Semaphore</code>, <code>CountDownLatch</code>.</p></section><section id="методы-синхронизации"><title><p>9. Методы синхронизации</p></title><p>• <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> (объекты мониторы).
</p><p>• <code>Lock.lock()/unlock()</code>.
</p><p>• <code>volatile</code> для видимости изменений между потоками.</p></section><section id="пул-потоков-thread-pool"><title><p>10. Пул потоков (Thread Pool)</p></title><p>• Набор переиспользуемых потоков для выполнения задач.
</p><empty-line /><p>• Создание:</p><empty-line /><empty-line /><p><code>  ExecutorService pool = Executors.newFixedThreadPool(4);</code></p><p><code>  pool.submit(() -&gt; { ... });</code></p><empty-line /></section><section id="forkjoinpool"><title><p>11. ForkJoinPool</p></title><p>• Специализированный пул для рекурсивных задач (разделяй и властвуй).
</p><p>• Особенности:</p><p>• • Работает через <code>ForkJoinTask</code> (например, <code>RecursiveTask</code>).
</p><p>• • Использует алгоритм “work-stealing” для балансировки нагрузки.</p></section></section><section id="базы-данных"><title><p>Базы данных</p></title><section id="агрегатные-операторы"><title><p>1. Агрегатные операторы</p></title><p>Функции для вычисления над набором значений, возвращающие одно значение. Примеры:</p><p>• <code>SUM()</code>: Сумма.
</p><p>• <code>AVG()</code>: Среднее.
</p><p>• <code>COUNT()</code>: Количество строк.
</p><p>• <code>MIN()</code>/<code>MAX()</code>: Минимум/максимум.</p></section><section id="нормальные-формы-нф"><title><p>2. Нормальные формы (НФ)</p></title><p>Правила проектирования БД для минимизации избыточности:</p><p>• 1НФ: Атомарные значения в ячейках.
</p><p>• 2НФ: Нет частичных зависимостей (ключ определяет все поля).
</p><p>• 3НФ: Нет транзитивных зависимостей.
</p><p>• BCNF: Усиленная 3НФ.</p></section><section id="индексы"><title><p>3. Индексы</p></title><p>Структуры для ускорения поиска. Типы:</p><p>• B-дерево: Для диапазонных запросов (основа — сбалансированное дерево).
</p><p>• Хэш-индекс: Точечный поиск (ключ → хэш).
</p><p>• Составной индекс: По нескольким столбцам.</p></section><section id="where-vs-having"><title><p>4. <code>WHERE</code> vs <code>HAVING</code></p></title><p>• <code>WHERE</code>: Фильтрация строк до группировки (<code>GROUP BY</code>).
</p><p>• <code>HAVING</code>: Фильтрация после группировки (работает с агрегатами).</p></section><section id="join"><title><p>5. <code>JOIN</code></p></title><p>Объединение таблиц по условию. Типы:</p><p>• <code>INNER JOIN</code>: Только совпадающие строки.
</p><p>• <code>LEFT/RIGHT JOIN</code>: Все строки левой/правой таблицы + совпадения.
</p><p>• <code>FULL JOIN</code>: Все строки обеих таблиц.
</p><p>• <code>CROSS JOIN</code>: Декартово произведение.</p></section><section id="основные-типы-данных-sql"><title><p>6. Основные типы данных SQL</p></title><p>• Числовые: <code>INT</code>, <code>DECIMAL</code>, <code>FLOAT</code>.
</p><p>• Строковые: <code>VARCHAR</code>, <code>TEXT</code>.
</p><p>• Дата/время: <code>DATE</code>, <code>TIMESTAMP</code>.
</p><p>• Логический: <code>BOOLEAN</code>.
</p><p>• Бинарные: <code>BLOB</code>.</p></section><section id="первичный-ключ-primary-key"><title><p>7. Первичный ключ (Primary Key)</p></title><p>• Уникальный идентификатор строки.
</p><p>• Не может быть <code>NULL</code>.
</p><p>• Гарантирует уникальность и целостность данных.
</p><p>• Пример: <code>id INT PRIMARY KEY</code>.</p></section></section><section id="spring"><title><p>Spring</p></title><section id="spring-framework-и-преимущества"><title><p>1. Spring Framework и преимущества</p></title><p>Платформа для разработки enterprise-приложений.
Преимущества:</p><p>• Инверсия управления (IoC) и внедрение зависимостей (DI).
</p><p>• Модульность (Spring MVC, Data, Security, Boot).
</p><p>• Упрощение интеграции (JPA, Hibernate, Kafka).
</p><p>• Сокращение шаблонного кода.</p></section><section id="модули-spring"><title><p>2. Модули Spring</p></title><p>• Core: IoC, DI.
</p><p>• MVC: Веб-приложения.
</p><p>• Data: Работа с БД (JPA, JDBC).
</p><p>• Security: Аутентификация/авторизация.
</p><p>• Boot: Быстрый старт приложений.
</p><p>• Cloud: Микросервисы.</p></section><section id="ioc-и-di"><title><p>3. IoC и DI</p></title><p>• IoC: Контейнер управляет жизненным циклом объектов.
</p><p>• DI: Зависимости передаются объектам извне (через конструктор, сеттеры, аннотации).
</p><p>• Пример: <code>@Autowired</code> для автоматического связывания.</p></section><section id="spring-bean"><title><p>4. Spring Bean</p></title><p>Объект, управляемый Spring-контейнером.
Создание:</p><p>• Аннотации (<code>@Component</code>, <code>@Service</code>, <code>@Controller</code>).
</p><p>• XML (<code>&lt;bean&gt;</code>).
</p><p>• Java-конфигурация (<code>@Bean</code> в <code>@Configuration</code>).</p></section><section id="жизненный-цикл-бина"><title><p>5. Жизненный цикл бина</p></title><p>1. Создание экземпляра.
</p><p>2. Внедрение зависимостей.
</p><p>3. Инициализация (<code>@PostConstruct</code>).
</p><p>4. Использование.
</p><p>5. Уничтожение (<code>@PreDestroy</code>).</p></section><section id="скоупы-бинов"><title><p>6. Скоупы бинов</p></title><p>• Singleton: Один экземпляр на контейнер (по умолчанию).
</p><p>• Prototype: Новый экземпляр при каждом запросе.
</p><p>• Request/Session/Application: Для веб-приложений.</p></section><section id="qualifier-и-primary"><title><p>7. @Qualifier и @Primary</p></title><p>• @Qualifier: Указывает конкретный бин при неоднозначности (например, <code>@Qualifier(&quot;beanName&quot;)</code>).
</p><p>• @Primary: Определяет бин по умолчанию при наличии нескольких реализаций.</p></section><section id="проблемы-и-решения"><title><p>8. Проблемы и решения</p></title><p>• Циклические зависимости: Использовать <code>@Lazy</code> или конструктор без зависимостей.
</p><p>• Производительность: Оптимизировать конфигурацию, использовать профили (<code>@Profile</code>).
</p><p>• Сложность конфигурации: Переход на Spring Boot с автонастройкой.</p></section></section><section id="spring-boot"><title><p>Spring Boot</p></title><section id="spring-boot-и-его-преимущества"><title><p>1. Spring Boot и его преимущества</p></title><p>• Фреймворк для быстрого создания Spring-приложений с минимальной конфигурацией.
</p><p>• Преимущества:</p><p>• • Автоконфигурация (автоматическая настройка бинов).
</p><p>• • Встроенные серверы (Tomcat, Jetty).
</p><p>• • Стартер-зависимости (<code>spring-boot-starter-*</code>).
</p><p>• • Готовые решения для метрик, мониторинга (Actuator).</p></section><section id="разница-между-spring-и-spring-boot"><title><p>2. Разница между Spring и Spring Boot</p></title><p>• Spring: Базовый фреймворк с ручной настройкой (XML, аннотации).
</p><p>• Spring Boot: Надстройка над Spring с «умными» дефолтами и автоматизацией конфигурации.</p></section><section id="service-component-repository"><title><p>3. @Service, @Component, @Repository</p></title><p>• @Component: Общая аннотация для любых бинов.
</p><p>• @Service: Специализация для бизнес-логики.
</p><p>• @Repository: Для DAO-слоя (добавляет обработку SQL-исключений).</p></section><section id="аннотации-spring-mvc"><title><p>4. Аннотации Spring MVC</p></title><p>• @Controller: Определяет класс как MVC-контроллер.
</p><p>• @RequestMapping, @GetMapping, @PostMapping: Маппинг URL.
</p><p>• @RequestParam, @PathVariable: Извлечение параметров запроса.
</p><p>• @ResponseBody: Возврат данных вместо представления.</p></section><section id="аннотация-value"><title><p>5. Аннотация @Value</p></title><p>Инъекция значений из properties-файлов или переменных окружения.
Пример:</p><empty-line /><p><code>@Value(&quot;${app.name}&quot;)  </code></p><p><code>private String appName;  </code></p><empty-line /></section><section id="spring-boot-starter"><title><p>6. Spring Boot Starter</p></title><p>Готовые наборы зависимостей для конкретных задач (например, <code>spring-boot-starter-web</code> включает Tomcat, Spring MVC).
Использование: Добавить в <code>pom.xml</code> или <code>build.gradle</code>.</p></section><section id="управление-конфигурацией"><title><p>7. Управление конфигурацией</p></title><p>• <code>application.properties</code>/<code>application.yml</code>: Основные настройки.
</p><p>• Профили (<code>@Profile</code>): Конфигурации для разных сред (dev, prod).
</p><p>• <code>@ConfigurationProperties</code>: Привязка свойств к Java-классам.</p></section><section id="инструменты-разработки-и-тестирования"><title><p>8. Инструменты разработки и тестирования</p></title><p>• DevTools: Hot reload, автоматический перезапуск.
</p><p>• Actuator: Эндпоинты для мониторинга (/health, /metrics).
</p><p>• Тестирование:</p><p>• • <code>@SpringBootTest</code> для интеграционных тестов.
</p><p>• • <code>@WebMvcTest</code> для тестирования контроллеров.
</p><p>• • <code>TestRestTemplate</code> для HTTP-запросов.</p></section></section><section id="spring-data"><title><p>Spring Data</p></title><section id="репозиторий-в-spring-data"><title><p>1. Репозиторий в Spring Data</p></title><p>Интерфейс для доступа к данным (CRUD-операции). Примеры:</p><p>• <code>CrudRepository</code>: Базовые операции (save, findById, delete).
</p><p>• <code>JpaRepository</code>: Расширенный API (пагинация, сортировка).</p><p>Использование:</p><empty-line /><p><code>public interface UserRepository extends JpaRepository&lt;User, Long&gt; { ... }  </code></p><empty-line /></section><section id="подключение-к-бд"><title><p>2. Подключение к БД</p></title><p>• Добавить зависимость (напр., <code>spring-boot-starter-data-jpa</code>).
</p><empty-line /><p>• Настроить <code>application.properties</code>:</p><empty-line /><empty-line /><p><code>  spring.datasource.url=jdbc:postgresql://localhost:5432/db  </code></p><p><code>  spring.datasource.username=user  </code></p><p><code>  spring.datasource.password=pass  </code></p><empty-line /></section><section id="требования-к-entity-классу"><title><p>3. Требования к Entity-классу</p></title><p>• Аннотация <code>@Entity</code>.
</p><p>• Поле с <code>@Id</code> (первичный ключ).
</p><p>• Конструктор без аргументов (по умолчанию).
</p><p>• Геттеры/сеттеры для полей (опционально).</p></section><section id="аннотация-query"><title><p>4. Аннотация <code>@Query</code></p></title><p>Позволяет задать кастомный JPQL/SQL-запрос:</p><empty-line /><p><code>@Query(&quot;SELECT u FROM User u WHERE u.active = true&quot;)  </code></p><p><code>List&lt;User&gt; findActiveUsers();  </code></p><empty-line /></section><section id="фетч-стратегии"><title><p>5. Фетч-стратегии</p></title><p>Определяют, когда загружать связанные сущности:</p><p>• EAGER: Немедленная загрузка (может привести к N+1).
</p><p>• LAZY: Ленивая загрузка (по умолчанию для <code>@ManyToMany</code>, <code>@OneToMany</code>).</p></section><section id="проблема-n1"><title><p>6. Проблема N+1</p></title><p>Суть: При загрузке N сущностей выполняется N+1 запрос (1 для основного списка + N для связанных данных).
Пример:</p><empty-line /><p><code>SELECT * FROM users;        -- 1 запрос  </code></p><p><code>SELECT * FROM orders WHERE user_id = 1;  </code></p><p><code>SELECT * FROM orders WHERE user_id = 2;  </code></p><p><code>...  </code></p><empty-line /><p>Решение:</p><p>• Использовать <code>JOIN FETCH</code> в JPQL:</p><empty-line /><empty-line /><p><code>  @Query(&quot;SELECT u FROM User u JOIN FETCH u.orders&quot;)  </code></p><p><code>  List&lt;User&gt; findAllWithOrders();  </code></p><empty-line /><p>• Настройка <code>@EntityGraph</code> для загрузки связей.</p><empty-line /></section></section></section></body></FictionBook>
