# Вопросы для подготовки

## Java Core

### 1. Типы данных в Java

- Примитивные: `byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean`.  
- Объектные (ссылочные): Все классы (включая `String`, массивы, пользовательские классы).  

### 2. Объектные vs примитивные типы  

- Примитивные хранят значение, объектные — ссылки.  
- Примитивные не могут быть `null`, имеют значения по умолчанию (например, `0`).  
- Объектные требуют больше памяти, поддерживают методы.  

### 3. Передача параметров  

- В Java всегда передача по значению:  
  - Для примитивов — копия значения.  
  - Для объектов — копия ссылки (изменения внутри метода влияют на объект).  

### 4. OutOfMemoryError  

- Ошибка при нехватке памяти в heap.  
- Причины: утечки памяти, большие структуры данных.  
- Диагностика: профилировщики (VisualVM, MAT).  

### 5. Стектрейс  

- Цепочка вызовов методов до точки ошибки.  
- Получить: `e.printStackTrace()` или `Thread.currentThread().getStackTrace()`.  

### 6. Методы класса Object  

- `toString()`, `equals()`, `hashCode()`, `clone()`, `getClass()`, `finalize()`, `notify()`, `notifyAll()`, `wait()` (3 перегрузки).  

### 7. Конструкторы  

- Специальные методы для инициализации объекта.  
- Типы: по умолчанию (без параметров), параметризованные, приватные (для singleton), копирования.  

### 8. Immutable стандартные классы  

- `String`, `Integer`, `Double`, `LocalDate`, `BigDecimal`, `Duration`, `UUID`.  

### 9. Immutable объекты  

- Характеристика: Состояние не меняется после создания.  
- Зачем: Безопасность в многопоточности, предсказуемость.  
- Создать: `final` класс + поля, отсутствие сеттеров, возврат копий в геттерах.  
- Преимущества: Потокобезопасность, простота кэширования, отсутствие side-эффектов.

## ООП

### 1. ООП

Парадигма программирования, основанная на объектах. Принципы:  

- Инкапсуляция (скрытие данных: `private` поля + геттеры/сеттеры).  
- Наследование (`class Dog extends Animal`).  
- Полиморфизм (перегрузка/переопределение методов).  
- Абстракция (интерфейсы, абстрактные классы).  

### 2. Наследование

Позволяет классу (потомку) использовать поля/методы другого класса (родителя). Пример: `class ElectricCar extends Car`.  
Зачем: Повторное использование кода, иерархия.  

### 3. Полиморфизм

Обращение к объектам разных классов через общий интерфейс. Работает через:  

- Переопределение методов (`@Override`).  
- Перегрузку методов (разные сигнатуры).  
Пример: `List<String> list = new ArrayList<>()`.  

### 4. Абстракция

Сокрытие сложности через интерфейсы/абстрактные классы. Пример: `interface Shape` с методом `draw()`.  

### 5. Инкапсуляция

- Модификаторы доступа (`private`, `protected`).  
- Геттеры/сеттеры.  
- Класс как капсула данных и методов.  

### 6. Наследование в Java  

- Ключевое слово `extends`.  
- `super`: вызов конструктора/метода родителя (`super()` или `super.method()`).  

### 7. Полиморфизм в Java  

- Переопределение методов (`@Override`).  
- Интерфейсы (`implements`).  
- Перегрузка методов (разные параметры).  

### 8. Перегрузка (overloading)  

Методы с одинаковым именем, но разными параметрами. Пример:  

```java
void print(int x) { ... }  
void print(String s) { ... }  
```  

### 9. Переопределение (override)  

Изменение реализации метода в подклассе. Пример:  

```java  
@Override  
public String toString() { ... }  
```  

### 10. Класс, объект, интерфейс  

- Класс: Шаблон для создания объектов.  
- Объект: Экземпляр класса.  
- Интерфейс: Контракт методов (`interface Runnable`).  

### 11. Элементы класса  

Поля, методы, конструкторы, вложенные классы, блоки инициализации.  

### 12. Сигнатура метода  

Имя метода + типы/порядок параметров. Пример: `add(int a, int b)`.  

### 13. return в конструкторе  

Да, можно использовать `return;` для завершения, но нельзя возвращать значение.  

### 14. Исключения в конструкторе  

Да, можно. Пример:  

```java  
public MyClass() throws IOException { ... }  
```  

### 15. Ключевое слово this  

- Разрешение конфликта имен (поля vs параметры).  
- Вызов других конструкторов (`this()`).  

### 16. Модификаторы доступа  

- `public`: Доступ везде.  
- `protected`: Тот же пакет + подклассы.  
- `private`: Только внутри класса.  
- По умолчанию: Тот же пакет.  

### 17. Статические переменные/методы  

- Принадлежат классу, а не объекту.  
- Ограничения: Не могут использовать `this`, обращаться к нестатическим полям/методам напрямую.  

### 18. Ключевое слово static  

- Статический метод можно перегрузить, но нельзя переопределить.  

### 19. Использование static методов  

- Статические методы можно вызывать из обычных (через имя класса).  
- Обычные методы нельзя вызвать из статических без объекта.  

### 20. final  

- Поля: Неизменяемые после инициализации.  
- Классы: Запрет наследования.  
- Методы: Запрет переопределения.  

### 21. abstract  

- Абстрактный класс: Нельзя создать объект.  
- Абстрактный метод: Без реализации (должен быть переопределен).  

### 22. interface  

Контракт методов. Не может быть `final` (должен быть реализован).  

### 23. Абстрактный класс vs интерфейс

- Абстрактный класс: Поля, конструкторы, реализация методов.  
- Интерфейс: Только абстрактные методы (до Java 8), константы.  

### 24. Модификаторы доступа класса

- `public`: Доступ везде.  
- Без модификатора (package-private): Только в том же пакете.

## String

### 1. Класс String в Java  

- Неизменяемый (immutable) класс для работы с последовательностями символов.  
- Реализует интерфейсы `CharSequence`, `Serializable`, `Comparable<String>`.  
- Хранится в куче (heap), но с оптимизацией через строковый пул (String Pool).  

### 2. Способы создания String  

- Литерал: `String s = "text";` (попадает в String Pool).  
- Через конструктор: `new String("text")` (создает новый объект в куче).  
- Из массива символов: `new char[] {'t','e','x','t'}`.  
- Через `StringBuilder`/`StringBuffer`: `new StringBuilder().toString()`.  

### 3. Сравнение и сортировка строк  

- `==`: Сравнивает ссылки, а не содержимое.  
- `equals()`: Сравнивает содержимое строк.  
- `compareTo()`: Для сортировки (возвращает разницу в Unicode).  
- `Arrays.sort()` или `Collections.sort()` с компаратором.  

### 4. Строковый пул (String Pool)  

- Специальная область в heap для хранения уникальных строковых литералов.  
- Цель: Экономия памяти за счет переиспользования строк.  
- При создании через литерал (`"text"`) JVM сначала проверяет String Pool.  

### 5. String vs StringBuffer vs StringBuilder  

- String: Неизменяемый. Подходит для констант, ключей в `HashMap`.  
- StringBuffer: Изменяемый, потокобезопасный (синхронизированные методы).  
- StringBuilder: Изменяемый, не потокобезопасный, быстрее StringBuffer.  
- Использовать:  
  - `String` для редко меняющихся данных.  
  - `StringBuilder` для однопоточных операций.  
  - `StringBuffer` для многопоточных.  

### Примеры

```java
// Создание строк
String s1 = "Hello";        // String Pool
String s2 = new String("Hello"); // Heap

// Сравнение
boolean isEqual = s1.equals(s2); // true

// StringBuilder
StringBuilder sb = new StringBuilder();
sb.append("Hello").append(" World");
String result = sb.toString(); // "Hello World"
```

## Enum

### 1. Краткая характеристика Enum  

- Тип данных для фиксированного набора констант (безопасная замена `int`/`String` констант).  
- Может содержать поля, методы, конструкторы.  
- Неявно наследуется от `java.lang.Enum`.  

### 2. Реализация интерфейса  

Да. Пример:  

  ```java
  interface Loggable { void log(); }  
  enum Status implements Loggable {  
    ACTIVE { public void log() { ... } },  
    INACTIVE { public void log() { ... } }  
  }  
  ```  

### 3. Наследование (extends)  

Нет. Enum не может наследовать классы (кроме неявного наследования от `java.lang.Enum`).  

### 4. Enum без экземпляров  

Нет. Должен содержать минимум одну константу.  

### 5. Переопределение `toString()`  

Да. Пример:  

  ```java
  enum Color { RED { public String toString() { return "Красный"; } }  
  ```  

### 6. Поведение `toString()` по умолчанию  

Возвращает имя константы (например, `RED` для `Color.RED`).  

### 7. Конструктор в Enum  

Да. Конструктор должен быть `private`:  

  ```java
  enum Size { SMALL(10), MEDIUM(20);  
    private int value;  
    private Size(int value) { this.value = value; }  
  }  
  ```  

### 8. `==` vs `equals()`  

- `==` сравнивает ссылки (безопасно, т.к. константы уникальны).  
- `equals()` вызывает `==` под капотом.  

### 9. Метод `ordinal()`  

- Возвращает порядковый номер константы (начинается с 0).  
- Пример: `Color.RED.ordinal()` → 0.  

### 10. Enum в `TreeSet`/`TreeMap`  

- Да. Сортировка по `natural order` (порядок объявления констант).  

### 11. Связь `ordinal()` и `compareTo()`  

- `compareTo()` использует `ordinal()` для сравнения.  

### 12. Enum в `switch case`  

- Да. Пример:  

  ```java
  switch (color) {  
    case RED: ... break;  
    case BLUE: ... break;  
  }  
  ```  

### 13. Получение всех значений Enum  

- Метод `values()`:  

  ```java
  Color[] colors = Color.values(); // [RED, GREEN, BLUE]  
  ```  

## Фунциональные интерфейсы

### 1. Функциональный интерфейс  

- Интерфейс с одним абстрактным методом (SAM).  
- Может иметь `default`/`static` методы.  
- Аннотация `@FunctionalInterface` (проверяет условие на этапе компиляции).  
- Пример: `Runnable`, `Comparator`.

### 2. Стандартные функциональные интерфейсы  

- `Predicate<T>`: Проверяет условие (`test(T t)` → `boolean`).  
- `Function<T,R>`: Преобразует `T` в `R` (`apply(T t)` → `R`).  
- `Consumer<T>`: Принимает `T`, ничего не возвращает (`accept(T t)`).  
- `Supplier<T>`: Поставляет значение (`get()` → `T`).  
- `UnaryOperator<T>`: `Function<T,T>` (например, `x -> x + 1`).  
- `BinaryOperator<T>`: Принимает два `T`, возвращает `T` (например, `(a, b) -> a + b`).

### 3. Лямбда-выражение  

- Анонимная функция, реализующая метод функционального интерфейса.  
- Синтаксис: `(параметры) -> { тело }`.  
- Пример:  

  ```java
  Function<Integer, Integer> square = x -> x * x;
  ```

### 4. Ссылка на метод (`::`)  

- Сокращенная запись для вызова существующего метода.  
- Типы:  
  - Статический метод: `ClassName::method`.  
  - Метод экземпляра: `instance::method` или `ClassName::method` (нестатический).  
  - Конструктор: `ClassName::new`.  
- Отличие от лямбды: Не создает новую реализацию, а ссылается на существующий метод.  
- Пример:  

  ```java
  Consumer<String> printer = System.out::println;
  ```

## Stream API

### 1. Stream API в Java  

Интерфейс для обработки коллекций/данных в функциональном стиле. Позволяет выполнять операции (фильтрация, преобразование, агрегация) цепочкой. Не изменяет исходные данные.  

### 2. Создание Stream из коллекции  

- `collection.stream()`: Создает последовательный стрим.  
- `collection.parallelStream()`: Создает параллельный стрим.  
- `Stream.of(...)`, `Arrays.stream(array)`: Для массивов/наборов элементов.  

### 3. Промежуточные операции  

Операции, возвращающие новый Stream (ленивые, выполняются при вызове терминальной операции). Примеры:  

- `filter(Predicate)`: Фильтрация элементов.  
- `map(Function)`: Преобразование элементов.  
- `sorted()`, `distinct()`, `limit(n)`.  

### 4. Терминальные операции  

Завершают обработку Stream, возвращают результат (число, коллекцию и т.д.). Примеры:  

- `collect(Collectors.toList())`: Сохранение в коллекцию.  
- `forEach(Consumer)`: Выполнение действия для каждого элемента.  
- `reduce()`, `count()`, `min()`, `max()`.  

### 5. Параллельные стримы  

Обработка элементов в нескольких потоках. Создается через `parallelStream()`. Требует осторожности с потокобезопасностью.  

### 6. Группировка элементов  

- `Collectors.groupingBy(Function)`: Группировка по ключу.  
- `Collectors.partitioningBy(Predicate)`: Разделение на `true`/`false`.  

### 7. Метод `filter`  

Принимает `Predicate<T>` (функцию, возвращающую `boolean`). Пример:  

```java  
list.stream().filter(s -> s.length() > 3)  
```  

### Дополнение

- Ленивые вычисления: Промежуточные операции выполняются только при вызове терминальной.  
- Порядок операций: Влияет на производительность (например, `filter` перед `map`).

## Collections

### 1. Иерархия коллекций  

- Интерфейсы: `Collection` → `List`, `Set`, `Queue`; `Map` (отдельная иерархия).  
- Реализации: `List` → `ArrayList`, `LinkedList`; `Set` → `HashSet`, `TreeSet`; `Map` → `HashMap`, `TreeMap`.  

### 2. Внутреннее строение ArrayList  

- Динамический массив (`Object[]`).  
- Начальная ёмкость: 10. При заполнении увеличивается на 50% (`newCapacity = oldCapacity + (oldCapacity >> 1)`).  

### 3. Внутреннее строение LinkedList  

- Двусвязный список: каждый элемент (`Node`) содержит ссылки на предыдущий и следующий узлы.  
- Нет необходимости в увеличении ёмкости, но больше памяти на ссылки.  

### 4. Внутреннее строение HashMap  

- Массив бакетов (по умолчанию: 16).  
- Каждый бакет — связный список или сбалансированное дерево (при коллизиях, Java 8+).  
- Хэш-функция: `hashCode()` ключа → индекс бакета.  

### 5. ArrayList vs LinkedList  

- ArrayList: Быстрый доступ по индексу (`O(1)`), медленные вставка/удаление в середине (`O(n)`).  
- LinkedList: Медленный доступ по индексу (`O(n)`), быстрые вставка/удаление (`O(1)`).  

### 6. ArrayList vs HashSet  

- ArrayList: Дубликаты разрешены, порядок элементов сохраняется.  
- HashSet: Дубликаты запрещены, порядок не гарантирован.  

### 7. Многообразие динамических массивов  

- Разные требования:  
  - `ArrayList` — для быстрого доступа.  
  - `Vector` — потокобезопасная версия.  
  - `CopyOnWriteArrayList` — для многопоточности.  

### 8. Многообразие key-value storage  

- HashMap: Быстрый доступ, порядок не гарантирован.  
- TreeMap: Сортировка по ключам (`Comparable`).  
- LinkedHashMap: Сохранение порядка вставки.  

### 9. Сортировка коллекции  

- `Collections.sort(list)` для `List`.  
- `TreeSet`/`TreeMap` — автоматическая сортировка.  
- Использование `Comparator` для кастомного порядка.  

### 10. Преимущество массива перед ArrayList  

- Производительность: Меньше накладных расходов.  
- Примитивы: Массивы поддерживают `int[]`, `double[]` (без автоупаковки).  
- Фиксированный размер: Предсказуемое использование памяти.

## Class Object. Equals and HashCode

### 1. Class Object  

Базовый класс всех объектов Java. Содержит методы: `equals()`, `hashCode()`, `toString()`, `clone()`, `finalize()`, `wait()`, `notify()`, `notifyAll()`.

### 2. Equals и HashCode  

- `equals()`: Сравнение объектов на семантическое равенство.  
- `hashCode()`: Генерация хэш-кода для использования в хэш-коллекциях (HashMap, HashSet).  

### 3. Контракт между equals и hashCode  

- Если `a.equals(b) == true`, то `a.hashCode() == b.hashCode()`.  
- Обратное неверно: одинаковые хэши не гарантируют равенство объектов.

### 4. Условия переопределения equals  

- Рефлексивность: `a.equals(a) == true`.  
- Симметричность: `a.equals(b) == b.equals(a)`.  
- Транзитивность: Если `a.equals(b)` и `b.equals(c)`, то `a.equals(c)`.  
- Консистентность: Результат не должен меняться между вызовами.  
- Неравенство с `null`: `a.equals(null) == false`.

### 5. Если не переопределить equals/hashCode  

- `equals()` сравнивает ссылки (`==`).  
- `hashCode()` возвращает адрес в памяти (не подходит для хэш-коллекций).

### 6. Значения без переопределения  

- `new Object().equals(new Object()) → false`.  
- `new Object().hashCode() ≠ new Object().hashCode()`.

### 7. Симметричность и `equals()`  

Симметричность нарушится, если в `equals()` участвуют разные классы. Пример:  

```java  
class A { ... }  
class B extends A { ... }  
a.equals(b) → true, но b.equals(a) → false.  
```

### 8. Коллизия hashCode  

Разные объекты имеют одинаковый хэш. Решения:  

- Хороший алгоритм хэширования.  
- В HashMap: связные списки/деревья в бакетах.

### 9. Изменение объекта в hash-коллекции  

Если объект изменен после добавления в коллекцию, его хэш может не соответствовать бакету → коллекция становится некорректной.

### 10. `instanceof` vs `getClass()`  

- `instanceof`: Разрешает сравнение с подклассами (может нарушить симметричность).  
- `getClass()`: Строгая проверка класса (гарантирует симметричность).

### 11. Метод clone()  

Создает копию объекта. Требует:  

- Реализации `Cloneable`.  
- Глубокого копирования (если объект содержит изменяемые поля).  
- Переопределения с `public` доступом.

## Exceptions

### 1. Определение исключения (exception)  

Исключение — событие, прерывающее нормальный поток выполнения программы. Используется для обработки ошибок (ошибки ввода, деление на ноль, доступ к null).

### 2. Особенности try...catch  

- `try`: Блок с кодом, где может возникнуть исключение.  
- `catch`: Ловит указанный тип исключения. Можно несколько `catch`.  
- `finally`: Выполняется всегда (даже при исключении).  

### 3. Error vs Exception  

- Error: Непроверяемые фатальные ошибки (OutOfMemoryError). Не обрабатываются.  
- Exception: Проверяемые/непроверяемые ошибки, которые можно обработать.  

### 4. Checked vs Unchecked, throw, throws  

- Checked: Наследники `Exception` (кроме RuntimeException). Требуют обработки.  
- Unchecked: Наследники `RuntimeException`.  
- throw: Выброс исключения (`throw new IOException()`).  
- throws: Объявление исключений в сигнатуре метода.  

### 5. Иерархия исключений  

- `Throwable` → `Error` (необрабатываемые) и `Exception` (обрабатываемые).  
- `Exception` → `RuntimeException` (unchecked) и другие (checked).  

### 6. Checked и Unchecked исключения  

- Checked: Обязательны для обработки (try-catch/throws). Пример: `IOException`.  
- Unchecked: Не требуют обработки. Пример: `NullPointerException`.  

### 7. Проверка Checked исключений  

Да. Компилятор требует их обработки или объявления в `throws`.  

### 8. Ключевое слово throws  

Указывает, какие исключения метод может выбросить. Пример:  

```java  
void readFile() throws IOException { ... }  
```  

### 9. Способы обработки исключений  

- `try-catch-finally`.  
- Проброс через `throws`.  
- Перехват в вызывающем коде.  

### 10. Правила при наследовании  

Переопределяемый метод не может объявлять более общие checked исключения, чем родительский.  

### 11. Оператор throw  

Выбрасывает исключение:  

```java  
if (x < 0) throw new IllegalArgumentException();  
```  

### 12. Метод main и throws  

Да, может. Исключение передается в JVM, которая завершает программу и печатает стектрейс.

## Память в Java

### 1. Как добиться StackOverflowError  

Бесконечная рекурсия:  

```java  
void recursiveMethod() { recursiveMethod(); }  
```  

Причина: Переполнение стека вызовов (ограниченная память под стек).  

### 2. OutOfMemoryError  

- Heap-память: Создание множества объектов без возможности удаления (например, бесконечный цикл с `new Object()`).  
- Metaspace/PermGen: Перегрузка классами (например, динамическая генерация классов).  

### 3. Garbage Collector (GC)  

Автоматически освобождает память от неиспользуемых объектов.  
Зачем: Управление памятью, предотвращение утечек.  

### 4. Heap vs Stack  

- Heap: Область для хранения объектов (управляется GC).  
- Stack: Хранит локальные переменные, вызовы методов (примитивы, ссылки). Работает по LIFO.  

### 5. Пул строк (String Pool)  

- Специальная область в Heap для уникальных строковых литералов.  
- Как работает:  
  - При создании через литерал (`"text"`): проверка наличия в пуле → возврат существующей строки.  
  - При `new String("text")`: создается новый объект вне пула.  
- Цель: Оптимизация памяти за счет переиспользования строк.  

Пример:  

```java  
String s1 = "hello";        // Пул  
String s2 = "hello";        // Существующий объект из пула  
String s3 = new String("hello"); // Новый объект в Heap  
```

## Многопоточность

### 1. Процесс и поток  

- Процесс: Изолированный экземпляр программы с собственным адресным пространством.  
- Поток (Thread): Легковесная единица выполнения внутри процесса. Потоки разделяют память процесса.

### 2. Многопоточность в Java  

- Параллельное выполнение нескольких потоков для повышения производительности.  
- Зачем: Распараллеливание задач (обработка запросов, асинхронные операции).

### 3. Создание и запуск потока  

- Наследование от `Thread` и переопределение `run()`.  
- Реализация `Runnable`/`Callable` и передача в `Thread` или пул потоков.  
- Запуск: `thread.start()` (не `run()`!).

### 4. Способы синхронизации  

- `synchronized` блоки/методы.  
- Локи (`ReentrantLock`, `StampedLock`).  
- Атомарные классы (`AtomicInteger`, `AtomicReference`).  
- `volatile` переменные.

### 5. Проблемы многопоточности  

- Состояние гонки (Race Condition).  
- Дэдлоки (Deadlock).  
- Голодание (Starvation).  
- Инверсия приоритетов.

### 6. Race Condition  

- Непредсказуемый результат из-за конкуренции потоков за ресурс.  
- Предотвращение: Синхронизация, атомарные операции, неизменяемые объекты.

### 7. Deadlock  

- Взаимная блокировка потоков из-за ожидания ресурсов.  
- Избежание:  
  - Упорядоченное получение локов.  
  - Использование `tryLock()` с таймаутом.

### 8. Классы и интерфейсы  

- `Thread`, `Runnable`, `Callable`, `Future`.  
- `ExecutorService`, `ThreadPoolExecutor`, `ForkJoinPool`.  
- `Lock`, `Semaphore`, `CountDownLatch`.

### 9. Методы синхронизации  

- `wait()`, `notify()`, `notifyAll()` (объекты мониторы).  
- `Lock.lock()/unlock()`.  
- `volatile` для видимости изменений между потоками.

### 10. Пул потоков (Thread Pool)  

- Набор переиспользуемых потоков для выполнения задач.  
- Создание:  

  ```java
  ExecutorService pool = Executors.newFixedThreadPool(4);
  pool.submit(() -> { ... });
  ```

### 11. ForkJoinPool  

- Специализированный пул для рекурсивных задач (разделяй и властвуй).  
- Особенности:  
  - Работает через `ForkJoinTask` (например, `RecursiveTask`).  
  - Использует алгоритм "work-stealing" для балансировки нагрузки.

## Базы данных

### 1. Агрегатные операторы  

Функции для вычисления над набором значений, возвращающие одно значение. Примеры:  

- `SUM()`: Сумма.  
- `AVG()`: Среднее.  
- `COUNT()`: Количество строк.  
- `MIN()`/`MAX()`: Минимум/максимум.  

### 2. Нормальные формы (НФ)  

Правила проектирования БД для минимизации избыточности:  

- 1НФ: Атомарные значения в ячейках.  
- 2НФ: Нет частичных зависимостей (ключ определяет все поля).  
- 3НФ: Нет транзитивных зависимостей.  
- BCNF: Усиленная 3НФ.  

### 3. Индексы  

Структуры для ускорения поиска. Типы:  

- B-дерево: Для диапазонных запросов (основа — сбалансированное дерево).  
- Хэш-индекс: Точечный поиск (ключ → хэш).  
- Составной индекс: По нескольким столбцам.  

### 4. `WHERE` vs `HAVING`  

- `WHERE`: Фильтрация строк до группировки (`GROUP BY`).  
- `HAVING`: Фильтрация после группировки (работает с агрегатами).  

### 5. `JOIN`  

Объединение таблиц по условию. Типы:  

- `INNER JOIN`: Только совпадающие строки.  
- `LEFT/RIGHT JOIN`: Все строки левой/правой таблицы + совпадения.  
- `FULL JOIN`: Все строки обеих таблиц.  
- `CROSS JOIN`: Декартово произведение.  

### 6. Основные типы данных SQL  

- Числовые: `INT`, `DECIMAL`, `FLOAT`.  
- Строковые: `VARCHAR`, `TEXT`.  
- Дата/время: `DATE`, `TIMESTAMP`.  
- Логический: `BOOLEAN`.  
- Бинарные: `BLOB`.  

### 7. Первичный ключ (Primary Key)  

- Уникальный идентификатор строки.  
- Не может быть `NULL`.  
- Гарантирует уникальность и целостность данных.  
- Пример: `id INT PRIMARY KEY`.

## Spring

### 1. Spring Framework и преимущества  

Платформа для разработки enterprise-приложений.  
Преимущества:  

- Инверсия управления (IoC) и внедрение зависимостей (DI).  
- Модульность (Spring MVC, Data, Security, Boot).  
- Упрощение интеграции (JPA, Hibernate, Kafka).  
- Сокращение шаблонного кода.  

### 2. Модули Spring  

- Core: IoC, DI.  
- MVC: Веб-приложения.  
- Data: Работа с БД (JPA, JDBC).  
- Security: Аутентификация/авторизация.  
- Boot: Быстрый старт приложений.  
- Cloud: Микросервисы.  

### 3. IoC и DI  

- IoC: Контейнер управляет жизненным циклом объектов.  
- DI: Зависимости передаются объектам извне (через конструктор, сеттеры, аннотации).  
- Пример: `@Autowired` для автоматического связывания.  

### 4. Spring Bean  

Объект, управляемый Spring-контейнером.  
Создание:  

- Аннотации (`@Component`, `@Service`, `@Controller`).  
- XML (`<bean>`).  
- Java-конфигурация (`@Bean` в `@Configuration`).  

### 5. Жизненный цикл бина  

1. Создание экземпляра.  
2. Внедрение зависимостей.  
3. Инициализация (`@PostConstruct`).  
4. Использование.  
5. Уничтожение (`@PreDestroy`).  

### 6. Скоупы бинов  

- Singleton: Один экземпляр на контейнер (по умолчанию).  
- Prototype: Новый экземпляр при каждом запросе.  
- Request/Session/Application: Для веб-приложений.  

### 7. @Qualifier и @Primary  

- @Qualifier: Указывает конкретный бин при неоднозначности (например, `@Qualifier("beanName")`).  
- @Primary: Определяет бин по умолчанию при наличии нескольких реализаций.  

### 8. Проблемы и решения  

- Циклические зависимости: Использовать `@Lazy` или конструктор без зависимостей.  
- Производительность: Оптимизировать конфигурацию, использовать профили (`@Profile`).  
- Сложность конфигурации: Переход на Spring Boot с автонастройкой.  

## Spring Boot

### 1. Spring Boot и его преимущества  

- Фреймворк для быстрого создания Spring-приложений с минимальной конфигурацией.  
- Преимущества:  
  - Автоконфигурация (автоматическая настройка бинов).  
  - Встроенные серверы (Tomcat, Jetty).  
  - Стартер-зависимости (`spring-boot-starter-*`).  
  - Готовые решения для метрик, мониторинга (Actuator).  

### 2. Разница между Spring и Spring Boot  

- Spring: Базовый фреймворк с ручной настройкой (XML, аннотации).  
- Spring Boot: Надстройка над Spring с «умными» дефолтами и автоматизацией конфигурации.  

### 3. @Service, @Component, @Repository  

- @Component: Общая аннотация для любых бинов.  
- @Service: Специализация для бизнес-логики.  
- @Repository: Для DAO-слоя (добавляет обработку SQL-исключений).  

### 4. Аннотации Spring MVC  

- @Controller: Определяет класс как MVC-контроллер.  
- @RequestMapping, @GetMapping, @PostMapping: Маппинг URL.  
- @RequestParam, @PathVariable: Извлечение параметров запроса.  
- @ResponseBody: Возврат данных вместо представления.  

### 5. Аннотация @Value  

Инъекция значений из properties-файлов или переменных окружения.  
Пример:  

```java  
@Value("${app.name}")  
private String appName;  
```  

### 6. Spring Boot Starter  

Готовые наборы зависимостей для конкретных задач (например, `spring-boot-starter-web` включает Tomcat, Spring MVC).  
Использование: Добавить в `pom.xml` или `build.gradle`.  

### 7. Управление конфигурацией  

- `application.properties`/`application.yml`: Основные настройки.  
- Профили (`@Profile`): Конфигурации для разных сред (dev, prod).  
- `@ConfigurationProperties`: Привязка свойств к Java-классам.  

### 8. Инструменты разработки и тестирования  

- DevTools: Hot reload, автоматический перезапуск.  
- Actuator: Эндпоинты для мониторинга (/health, /metrics).  
- Тестирование:  
  - `@SpringBootTest` для интеграционных тестов.  
  - `@WebMvcTest` для тестирования контроллеров.  
  - `TestRestTemplate` для HTTP-запросов.  

## Spring Data

### 1. Репозиторий в Spring Data  

Интерфейс для доступа к данным (CRUD-операции). Примеры:  

- `CrudRepository`: Базовые операции (save, findById, delete).  
- `JpaRepository`: Расширенный API (пагинация, сортировка).  

Использование:  

```java  
public interface UserRepository extends JpaRepository<User, Long> { ... }  
```  

### 2. Подключение к БД  

- Добавить зависимость (напр., `spring-boot-starter-data-jpa`).  
- Настроить `application.properties`:  

  ```properties  
  spring.datasource.url=jdbc:postgresql://localhost:5432/db  
  spring.datasource.username=user  
  spring.datasource.password=pass  
  ```  

### 3. Требования к Entity-классу  

- Аннотация `@Entity`.  
- Поле с `@Id` (первичный ключ).  
- Конструктор без аргументов (по умолчанию).  
- Геттеры/сеттеры для полей (опционально).  

### 4. Аннотация `@Query`  

Позволяет задать кастомный JPQL/SQL-запрос:  

```java  
@Query("SELECT u FROM User u WHERE u.active = true")  
List<User> findActiveUsers();  
```  

### 5. Фетч-стратегии  

Определяют, когда загружать связанные сущности:  

- EAGER: Немедленная загрузка (может привести к N+1).  
- LAZY: Ленивая загрузка (по умолчанию для `@ManyToMany`, `@OneToMany`).  

### 6. Проблема N+1  

Суть: При загрузке N сущностей выполняется N+1 запрос (1 для основного списка + N для связанных данных).  
Пример:  

```sql  
SELECT * FROM users;        -- 1 запрос  
SELECT * FROM orders WHERE user_id = 1;  
SELECT * FROM orders WHERE user_id = 2;  
...  
```  

Решение:  

- Использовать `JOIN FETCH` в JPQL:  

  ```java  
  @Query("SELECT u FROM User u JOIN FETCH u.orders")  
  List<User> findAllWithOrders();  
  ```  

- Настройка `@EntityGraph` для загрузки связей.
