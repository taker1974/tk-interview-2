# Collections

## 1. Иерархия коллекций  

- Интерфейсы: `Collection` → `List`, `Set`, `Queue`; `Map` (отдельная иерархия).  
- Реализации: `List` → `ArrayList`, `LinkedList`; `Set` → `HashSet`, `TreeSet`; `Map` → `HashMap`, `TreeMap`.  

## 2. Внутреннее строение ArrayList  

- Динамический массив (`Object[]`).  
- Начальная ёмкость: 10. При заполнении увеличивается на 50% (`newCapacity = oldCapacity + (oldCapacity >> 1)`).  

## 3. Внутреннее строение LinkedList  

- Двусвязный список: каждый элемент (`Node`) содержит ссылки на предыдущий и следующий узлы.  
- Нет необходимости в увеличении ёмкости, но больше памяти на ссылки.  

## 4. Внутреннее строение HashMap  

- Массив бакетов (по умолчанию: 16).  
- Каждый бакет — связный список или сбалансированное дерево (при коллизиях, Java 8+).  
- Хэш-функция: `hashCode()` ключа → индекс бакета.  

## 5. ArrayList vs LinkedList  

- ArrayList: Быстрый доступ по индексу (`O(1)`), медленные вставка/удаление в середине (`O(n)`).  
- LinkedList: Медленный доступ по индексу (`O(n)`), быстрые вставка/удаление (`O(1)`).  

## 6. ArrayList vs HashSet  

- ArrayList: Дубликаты разрешены, порядок элементов сохраняется.  
- HashSet: Дубликаты запрещены, порядок не гарантирован.  

## 7. Многообразие динамических массивов  

- Разные требования:  
  - `ArrayList` — для быстрого доступа.  
  - `Vector` — потокобезопасная версия.  
  - `CopyOnWriteArrayList` — для многопоточности.  

## 8. Многообразие key-value storage  

- HashMap: Быстрый доступ, порядок не гарантирован.  
- TreeMap: Сортировка по ключам (`Comparable`).  
- LinkedHashMap: Сохранение порядка вставки.  

## 9. Сортировка коллекции  

- `Collections.sort(list)` для `List`.  
- `TreeSet`/`TreeMap` — автоматическая сортировка.  
- Использование `Comparator` для кастомного порядка.  

## 10. Преимущество массива перед ArrayList  

- Производительность: Меньше накладных расходов.  
- Примитивы: Массивы поддерживают `int[]`, `double[]` (без автоупаковки).  
- Фиксированный размер: Предсказуемое использование памяти.
