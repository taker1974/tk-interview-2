# Фунциональные интерфейсы

## 1. Функциональный интерфейс  

- Интерфейс с одним абстрактным методом (SAM).  
- Может иметь `default`/`static` методы.  
- Аннотация `@FunctionalInterface` (проверяет условие на этапе компиляции).  
- Пример: `Runnable`, `Comparator`.

## 2. Стандартные функциональные интерфейсы  

- `Predicate<T>`: Проверяет условие (`test(T t)` → `boolean`).  
- `Function<T,R>`: Преобразует `T` в `R` (`apply(T t)` → `R`).  
- `Consumer<T>`: Принимает `T`, ничего не возвращает (`accept(T t)`).  
- `Supplier<T>`: Поставляет значение (`get()` → `T`).  
- `UnaryOperator<T>`: `Function<T,T>` (например, `x -> x + 1`).  
- `BinaryOperator<T>`: Принимает два `T`, возвращает `T` (например, `(a, b) -> a + b`).

## 3. Лямбда-выражение  

- Анонимная функция, реализующая метод функционального интерфейса.  
- Синтаксис: `(параметры) -> { тело }`.  
- Пример:  

  ```java
  Function<Integer, Integer> square = x -> x * x;
  ```

## 4. Ссылка на метод (`::`)  

- Сокращенная запись для вызова существующего метода.  
- Типы:  
  - Статический метод: `ClassName::method`.  
  - Метод экземпляра: `instance::method` или `ClassName::method` (нестатический).  
  - Конструктор: `ClassName::new`.  
- Отличие от лямбды: Не создает новую реализацию, а ссылается на существующий метод.  
- Пример:  

  ```java
  Consumer<String> printer = System.out::println;
  ```
